<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆä¿®æ­£ç‰ˆï¼‰</title>
<style>
    body { font-family: "Helvetica Neue", Arial, sans-serif; padding: 20px; background-color: #f4f6f9; color: #333; }
    h1 { font-size: 1.4rem; margin-bottom: 10px; border-bottom: 2px solid #ddd; padding-bottom: 10px; }
    .container { max-width: 1500px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    
    .header-top { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 15px;
    }
    .header-top h1 { 
        margin: 0; 
        flex: 1;
    }
    
    #sourceButton {
        padding: 10px 20px;
        background-color: #6c757d;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        text-decoration: none;
        display: inline-block;
        white-space: nowrap;
    }
    #sourceButton:hover { background-color: #5a6268; }
    
    .input-area { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
    textarea { width: 100%; height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px; }
    
    .controls { margin-top: 15px; display: flex; gap: 15px; align-items: center; background: #eef; padding: 15px; border-radius: 5px; flex-wrap: wrap; }
    input[type="text"], input[type="number"] { padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
    input[type="number"] { width: 80px; }
    button { padding: 10px 24px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
    button:hover { background-color: #0056b3; }
    
    #errorMessage { color: red; font-weight: bold; margin-top: 10px; }
    
    .tables-container { display: flex; flex-direction: column; gap: 30px; }
    .gender-section h2 { background-color: #343a40; color: white; padding: 10px; margin: 0; font-size: 1.1rem; border-radius: 4px 4px 0 0; }
    
    table { width: 100%; border-collapse: collapse; font-size: 13px; background: white; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
    th { 
        background-color: #f8f9fa; 
        color: #333; 
        font-weight: bold; 
        cursor: pointer;
        user-select: none;
        position: relative;
    }
    th:hover { background-color: #e2e6ea; }
    th.sort-asc::after { content: " â–²"; color: #007bff; }
    th.sort-desc::after { content: " â–¼"; color: #007bff; }
    
    tr:nth-child(even) { background-color: #fcfcfc; }
    tr:hover { background-color: #f1f1f1; }
    
    .market-name-col { text-align: left; font-weight: bold; }
    .total-row { background-color: #e9ecef; font-weight: bold; }
    .total-row td { background-color: #e9ecef; }
    
    .score-value { font-weight: bold; font-size: 1.1em; }
    .score-positive { color: #28a745; }
    .score-negative { color: #dc3545; }
    .score-zero { color: #6c757d; }
</style>
</head>
<body>

<div class="container">
    <div class="header-top">
        <h1>ğŸ“Š å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆã‚¹ã‚³ã‚¢ç‰ˆï¼‰</h1>
        <a id="sourceButton" href="https://www.alic.go.jp/operation/livestock/calf-report.html" target="_blank">è‚‰ç”¨å­ç‰›å–å¼•æƒ…å ±ã‚µã‚¤ãƒˆã¸</a>
    </div>
    
    <div class="input-area">
        <textarea id="dataInput" placeholder="Excelã®ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„..."></textarea>
        <div class="controls">
            <label>æŠ½å‡ºå¯¾è±¡å¹´: <input type="number" id="targetYear" value="2025" placeholder="ä¾‹: 2025"></label>
            <label>æŠ½å‡ºå¯¾è±¡æœˆ: <input type="text" id="targetMonth" value="8" placeholder="ä¾‹: 8"></label>
            <button onclick="processData()">ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ï¼†è¡¨ä½œæˆ</button>
        </div>
        <div id="errorMessage"></div>
    </div>

    <div id="resultArea" class="tables-container"></div>
</div>

<script>
    let parsedDataByGender = { 'é›„': [], 'é›Œ': [], 'è¨ˆ': [] };
    let marketMap = {};
    let sortState = {
        'é›„': { key: null, dir: 'desc' },
        'é›Œ': { key: null, dir: 'desc' },
        'è¨ˆ': { key: null, dir: 'desc' }
    };

    const metricsMap = [
        { key: 'count', label: 'å–å¼•é ­æ•°', unit: 'é ­' },
        { key: 'price', label: 'å¹³å‡ä¾¡æ ¼', unit: 'å††' },
        { key: 'weight', label: 'å¹³å‡ä½“é‡', unit: 'kg' },
        { key: 'age', label: 'å¹³å‡æ—¥é½¢', unit: 'æ—¥' },
        { key: 'unitPrice', label: '1kgå˜ä¾¡', unit: 'å††' }
    ];

    function processData() {
        const text = document.getElementById('dataInput').value;
        const targetMonth = document.getElementById('targetMonth').value.trim();
        const errorDiv = document.getElementById('errorMessage');
        const resultDiv = document.getElementById('resultArea');
        
        errorDiv.textContent = "";
        resultDiv.innerHTML = "";
        parsedDataByGender = { 'é›„': [], 'é›Œ': [], 'è¨ˆ': [] };
        marketMap = {};
        sortState = {
            'é›„': { key: null, dir: 'desc' },
            'é›Œ': { key: null, dir: 'desc' },
            'è¨ˆ': { key: null, dir: 'desc' }
        };

        if (!text) {
            errorDiv.textContent = "ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚";
            return;
        }

        const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        
        // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‹ã‚‰åˆ—ä½ç½®ã‚’ç‰¹å®š
        let monthIndex = -1;
        let headerLine = null;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (line.includes('å¸‚å ´å')) {
                headerLine = line;
                break;
            }
        }

        if (!headerLine) {
            errorDiv.textContent = "ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œï¼ˆå¸‚å ´åã‚’å«ã‚€ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚";
            return;
        }

        // ãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚‰æœˆã®åˆ—ã‚’ç‰¹å®š
        const headerParts = headerLine.split('\t').map(p => p.trim());
        for (let i = 0; i < headerParts.length; i++) {
            const part = headerParts[i];
            if (part === targetMonth || part.endsWith('æœˆ' + targetMonth) || part === targetMonth + 'æœˆ') {
                monthIndex = i;
                break;
            }
        }

        if (monthIndex === -1) {
            errorDiv.textContent = `å¯¾è±¡æœˆï¼ˆ${targetMonth}æœˆï¼‰ãŒãƒ˜ãƒƒãƒ€ãƒ¼ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`;
            return;
        }

        console.log('æœˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹:', monthIndex, 'ãƒ˜ãƒƒãƒ€ãƒ¼:', headerParts);

        // ãƒ‡ãƒ¼ã‚¿è§£æ
        let currentMarketName = null;
        let headerLineIndex = -1;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if (line.includes('å¸‚å ´å')) {
                headerLineIndex = i;
                continue;
            }

            // å¸‚å ´åè¡Œã®åˆ¤å®š
            const parts = line.split('\t').map(p => p.trim()).filter(p => p.length > 0);
            
            const isMarketHeader = (
                parts.length >= 2 &&
                (line.includes("é“") || line.includes("çœŒ") || line.includes("åºœ") || line.includes("éƒ½")) &&
                (line.includes("å¸‚å ´") || line.includes("é›†æ•£")) &&
                !line.includes("é ­") && !line.includes("ä¾¡æ ¼") && !line.includes("ä½“é‡") && 
                !line.includes("æ—¥é½¢") && !line.includes("å˜ä¾¡") && !line.includes("ï¼ˆ")
            );

            if (isMarketHeader) {
                let name = parts.slice(1).join(' ').replace(/ï¼Š|\*/g, "").trim();
                if (name.includes("å“ç¨®") || name.includes("é»’æ¯›å’Œç¨®")) continue;
                
                currentMarketName = name;
                if (!marketMap[currentMarketName]) {
                    marketMap[currentMarketName] = { 'é›„': {}, 'é›Œ': {}, 'è¨ˆ': {} };
                }
                continue;
            }

            if (!currentMarketName || i <= headerLineIndex) continue;

            // æŒ‡æ¨™åã®åˆ¤å®š
            let detectedMetric = null;
            if (line.includes("å–å¼•é ­æ•°")) detectedMetric = "count";
            else if (line.includes("å¹³å‡ä¾¡æ ¼")) detectedMetric = "price";
            else if (line.includes("å¹³å‡ä½“é‡")) detectedMetric = "weight";
            else if (line.includes("å¹³å‡æ—¥é½¢")) detectedMetric = "age";
            else if (line.includes("1kgå˜ä¾¡") || line.includes("ï¼‘ãå˜ä¾¡") || line.includes("kgå˜ä¾¡")) detectedMetric = "unitPrice";

            if (detectedMetric) {
                // æ¬¡ã®3è¡Œã‚’è§£æï¼ˆé›Œã€é›„ã€è¨ˆï¼‰
                const line1 = i + 1 < lines.length ? lines[i + 1] : "";
                const line2 = i + 2 < lines.length ? lines[i + 2] : "";
                const line3 = i + 3 < lines.length ? lines[i + 3] : "";

                // å„è¡Œã‹ã‚‰æ•°å€¤ã‚’æŠ½å‡º
                extractMetricData(line1, 'é›Œ', detectedMetric, monthIndex);
                extractMetricData(line2, 'é›„', detectedMetric, monthIndex);
                extractMetricData(line3, 'è¨ˆ', detectedMetric, monthIndex);
            }
        }

        function extractMetricData(line, gender, metricKey, monthIdx) {
            if (!line) return;
            
            // ã‚¿ãƒ–ã§åˆ†å‰²
            const parts = line.split('\t').map(p => p.trim());
            
            // æœ€åˆã®2åˆ—ï¼ˆæ€§åˆ¥ãƒ»å˜ä½ï¼‰ã‚’é™¤ã„ãŸæ•°å€¤éƒ¨åˆ†ã‚’æŠ½å‡º
            const numberParts = parts.slice(1);
            
            // å„è¦ç´ ã‚’æ•°å€¤ã«å¤‰æ›
            let numberIndex = 0;
            for (let i = 0; i < numberParts.length; i++) {
                const part = numberParts[i];
                const num = parseFloat(part.replace(/,/g, ''));
                
                if (!isNaN(num) && num !== 0) {
                    if (numberIndex === monthIdx) {
                        if (!marketMap[currentMarketName][gender]) {
                            marketMap[currentMarketName][gender] = {};
                        }
                        marketMap[currentMarketName][gender][metricKey] = num;
                        break;
                    }
                    numberIndex++;
                }
            }
        }

        // ãƒ‡ãƒ¼ã‚¿ã‚’é…åˆ—ã«å¤‰æ›ï¼ˆç·åˆè¨ˆã‚‚å«ã‚ã‚‹ï¼‰
        Object.keys(marketMap).forEach(mName => {
            ['é›„', 'é›Œ', 'è¨ˆ'].forEach(g => {
                let dataObj = { name: mName, isTotal: false };
                let hasData = false;
                metricsMap.forEach(m => {
                    const val = marketMap[mName][g][m.key];
                    dataObj[m.key] = val || null;
                    if (val !== undefined && val !== null && val !== 0) {
                        hasData = true;
                    }
                });
                if (hasData) {
                    parsedDataByGender[g].push(dataObj);
                }
            });
        });

        if (parsedDataByGender['è¨ˆ'].length === 0 && parsedDataByGender['é›„'].length === 0) {
            errorDiv.textContent = "æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚";
            return;
        }

        // ã‚¹ã‚³ã‚¢è¨ˆç®—
        calculateScores();
        renderTables();
    }

    function calculateScores() {
        ['é›„', 'é›Œ', 'è¨ˆ'].forEach(gender => {
            const data = parsedDataByGender[gender];

            metricsMap.forEach(m => {
                const metricKey = m.key;
                
                // ç·åˆè¨ˆè¡Œã‚’æ¢ã™
                const totalRow = data.find(row => row.name && row.name.includes('åˆè¨ˆ'));
                const totalValue = totalRow ? totalRow[metricKey] : null;
                
                // å¸‚å ´ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚’æŠ½å‡ºï¼ˆç·åˆè¨ˆã‚’é™¤å¤–ï¼‰
                const marketData = data.filter(row => !row.name.includes('åˆè¨ˆ'));
                const validData = marketData.filter(row => row[metricKey] !== undefined && row[metricKey] !== null);
                
                if (validData.length === 0) return;

                const values = validData.map(row => row[metricKey]);

                if (metricKey === 'count') {
                    // å–å¼•é ­æ•°: å¸‚å ´ã®ã¿ã§é †ä½ä»˜ã‘ã€ç·åˆè¨ˆã¯ã€Œ-ã€
                    const sortedValues = values.slice().sort((a, b) => b - a);
                    const numMarkets = sortedValues.length;

                    data.forEach(row => {
                        if (row.name.includes('åˆè¨ˆ')) {
                            row[`${metricKey}Score`] = '-';
                        } else if (row[metricKey] === null || row[metricKey] === undefined) {
                            row[`${metricKey}Score`] = null;
                        } else {
                            const rankIndex = sortedValues.findIndex(v => v === row[metricKey]);
                            row[`${metricKey}Score`] = numMarkets - rankIndex;
                        }
                    });
                } else {
                    // ãã®ä»–ã®æŒ‡æ¨™: ç·åˆè¨ˆã‚’å«ã‚ã¦é †ä½ä»˜ã‘
                    const allValues = [...values];
                    if (totalValue !== null && totalValue !== undefined) {
                        allValues.push(totalValue);
                    }
                    
                    const sortedValues = allValues.slice().sort((a, b) => b - a);
                    const totalRankIndex = totalValue !== null ? sortedValues.findIndex(v => v === totalValue) : -1;
                    
                    data.forEach(row => {
                        if (row[metricKey] === null || row[metricKey] === undefined) {
                            row[`${metricKey}Score`] = null;
                        } else {
                            const rankIndex = sortedValues.findIndex(v => v === row[metricKey]);
                            
                            if (row.name.includes('åˆè¨ˆ')) {
                                // ç·åˆè¨ˆã¯å¸¸ã«0
                                row[`${metricKey}Score`] = 0;
                            } else if (totalRankIndex !== -1) {
                                // ç·åˆè¨ˆã¨ã®ç›¸å¯¾é †ä½ã‚’è¨ˆç®—
                                row[`${metricKey}Score`] = totalRankIndex - rankIndex;
                            } else {
                                row[`${metricKey}Score`] = rankIndex;
                            }
                        }
                    });
                }
            });
        });
    }

    function formatScoreValue(score) {
        if (score === undefined || score === null) return `-`;
        if (score === '-') return `-`;
        
        const num = parseInt(score, 10);
        if (num === 0) return `<span class="score-value score-zero">0</span>`;
        
        const formatted = num > 0 ? `+${num}` : `${num}`;
        const scoreClass = num > 0 ? "score-positive" : "score-negative";
        
        return `<span class="score-value ${scoreClass}">${formatted}</span>`;
    }

    function sortTable(gender, key) {
        const data = parsedDataByGender[gender];
        
        if (sortState[gender].key === key) {
            sortState[gender].dir = sortState[gender].dir === 'asc' ? 'desc' : 'asc';
        } else {
            sortState[gender].key = key;
            sortState[gender].dir = 'desc';
        }

        const dir = sortState[gender].dir;

        data.sort((a, b) => {
            let valA, valB;

            if (key === 'name') {
                valA = a.name;
                valB = b.name;
                const comp = valA.localeCompare(valB, 'ja');
                return dir === 'asc' ? comp : -comp;
            }

            if (key.endsWith('Score')) {
                valA = a[key] === '-' ? -Infinity : (a[key] !== null ? a[key] : Infinity);
                valB = b[key] === '-' ? -Infinity : (b[key] !== null ? b[key] : Infinity);
                return dir === 'asc' ? valA - valB : valB - valA;
            }

            valA = a[key] || 0;
            valB = b[key] || 0;

            return dir === 'asc' ? valA - valB : valB - valA;
        });

        renderTables();
    }

    function renderTables() {
        const container = document.getElementById('resultArea');
        container.innerHTML = "";

        ['é›„', 'é›Œ', 'è¨ˆ'].forEach(gender => {
            const data = parsedDataByGender[gender];
            
            if (data.length === 0) return;

            // ç·åˆè¨ˆã‚’æœ€å¾Œã«é…ç½®
            const marketData = data.filter(row => !row.name.includes('åˆè¨ˆ'));
            const totalData = data.filter(row => row.name.includes('åˆè¨ˆ'));
            const sortedData = [...marketData, ...totalData];

            const section = document.createElement('div');
            section.className = 'gender-section';
            
            let html = `<h2>ã€${gender}ã€‘ å¸‚å ´ã‚¹ã‚³ã‚¢ä¸€è¦§</h2>
            <table>
                <thead>
                    <tr>
                        <th onclick="sortTable('${gender}', 'name')" class="${sortState[gender].key === 'name' ? 'sort-' + sortState[gender].dir : ''}">å¸‚å ´</th>`;
            
            metricsMap.forEach(m => {
                const isSorted = sortState[gender].key === m.key;
                const sortClass = isSorted ? 'sort-' + sortState[gender].dir : '';
                html += `<th onclick="sortTable('${gender}', '${m.key}')" class="${sortClass}">${m.label}<br><small>${m.unit}</small></th>`;
            });

            html += `</tr></thead><tbody>`;

            sortedData.forEach(row => {
                const isTotal = row.name.includes('åˆè¨ˆ');
                const rowClass = isTotal ? 'class="total-row"' : '';
                html += `<tr ${rowClass}>
                            <td class="market-name-col">${row.name}</td>`;
                metricsMap.forEach(m => {
                    const score = row[`${m.key}Score`];
                    html += `<td>${formatScoreValue(score)}</td>`;
                });
                html += `</tr>`;
            });

            html += `</tbody></table>`;
            section.innerHTML = html;
            container.appendChild(section);
        });
    }

    window.onload = function() {
        document.getElementById('dataInput').value = `å¸‚å ´å	12æœˆ	1æœˆ	2æœˆ	3æœˆ	4æœˆ	5æœˆ	6æœˆ	7æœˆ	8æœˆ	9æœˆ	10æœˆ	11æœˆ	åˆè¨ˆãƒ»å¹³å‡
åŒ—æµ·é“	ãƒ›ã‚¯ãƒ¬ãƒ³å—åŒ—æµ·é“å®¶ç•œå¸‚å ´
	å–å¼•é ­æ•°
	ï¼ˆé ­ï¼‰	é›Œ	785	563	676	625	688	718	690	681	597	604	585	601	7028
		é›„	944	805	902	789	940	1060	929	812	794	881	842	865	9619
		è¨ˆ	1729	1368	1578	1414	1628	1778	1619	1493	1391	1485	1427	1466	16647
	å¹³å‡ä¾¡æ ¼
	ï¼ˆå††ï¼‰	é›Œ	476069	525605	547652	580108	677015	629563	595819	646333	664295	609425	633152	674834	617306
		é›„	600128	656085	683328	722827	805909	745047	747471	777784	778781	751776	753167	793066	747367
		è¨ˆ	543803	602386	625206	659744	751438	698412	682838	717826	729645	693877	703967	744596	692458
	å¹³å‡ä½“é‡
	ï¼ˆKgï¼‰	é›Œ	312	316	314	311	317	317	318	314	311	314	314	320	315
		é›„	331	336	335	334	342	341	342	340	334	340	339	345	339
		è¨ˆ	322	328	326	324	331	332	331	328	324	330	329	335	329
	å¹³å‡æ—¥é½¢
	ï¼ˆæ—¥ï¼‰	é›Œ	301	308	308	306	309	307	304	305	302	306	303	309	306
		é›„	290	296	297	296	298	296	295	292	291	295	293	297	295
		è¨ˆ	295	301	302	301	303	300	299	298	295	299	297	302	300
	ï¼‘ãå˜ä¾¡
	ï¼ˆå††ï¼‰	é›Œ	1526	1661	1747	1864	2139	1983	1876	2059	2137	1939	2014	2110	1959
		é›„	1813	1953	2038	2165	2355	2183	2189	2285	2331	2211	2220	2298	2203
		è¨ˆ	1687	1837	1918	2037	2268	2106	2061	2186	2251	2105	2139	2224	2105`;
    };
</script>

</body>
</html>
