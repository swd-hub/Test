<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆå®Œå…¨ãªç›´ç·šæŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ç‰ˆï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; padding: 20px; background-color: #f4f6f9; color: #333; }
        h1 { font-size: 1.4rem; margin-bottom: 10px; border-bottom: 2px solid #ddd; padding-bottom: 10px; }

        .container { 
            max-width: 1800px; 
            margin: 0 auto; 
            background: #fff; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
        }

        .header-top { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .header-top h1 { margin: 0; flex: 1; min-width: 300px; } 
        #sourceButton {
            padding: 10px 20px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
        }
        #sourceButton:hover { background-color: #5a6268; }

        .input-area { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
        textarea { width: 100%; height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px; }
        .controls { margin-top: 15px; display: flex; gap: 30px; align-items: center; background: #eef; padding: 15px; border-radius: 5px; flex-wrap: wrap; }
        .radio-group label { margin-right: 15px; font-weight: bold; }
        #errorMessage { color: red; font-weight: bold; margin-top: 10px; }


        .analysis-pair-container {
            margin-top: 30px;
            padding: 20px 0;
            border-top: 3px solid #6c757d;
            
            display: grid;
            grid-template-columns: minmax(40%, 700px) 1fr; 
            gap: 20px;
        }

        .table-section {
            background: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-radius: 8px;
            overflow-x: auto;
            max-height: 800px;
        }
        
        .table-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #343a40; 
            color: white; 
            padding: 10px; 
            margin: 0; 
            font-size: 1.1rem; 
            border-radius: 8px 8px 0 0;
        }
        .table-section h2 { 
            margin: 0; 
            font-size: 1.1rem; 
        }

        #marketSelectionControls button {
            background-color: #f8d7da; 
            color: #721c24; 
            border: 1px solid #f5c6cb;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
        }
        #marketSelectionControls button:hover {
            background-color: #f5c6cb;
        }


        table { 
            width: 100%; 
            min-width: 800px;
            border-collapse: collapse; 
            font-size: 13px; 
            background: white; 
        }
        th, td { border: 1px solid #ddd; padding: 5px; text-align: center; } 
        th { 
            background-color: #f8f9fa; 
            color: #333; 
            font-weight: bold; 
        }
        td { white-space: nowrap; }

        tr:nth-child(even) { background-color: #fcfcfc; }
        tr:hover { background-color: #f1f1f1; }

        .checkbox-cell { width: 40px; } 
        .pref-col { text-align: left; font-weight: normal; width: 80px; }
        .market-col { text-align: left; font-weight: bold; width: 150px; }
        
        .total-row { background-color: #e9ecef; font-weight: bold; }
        .score-value { font-weight: bold; color: #000; } 


        .graph-section {
            padding: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-height: 800px;
            min-height: 600px; 
        }
        .graph-section h2 {
            font-size: 1.1rem;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 10px;
            margin-top: 0;
        }
        canvas { height: 100%; width: 100%; }

        @media (max-width: 1200px) {
            .analysis-pair-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .table-section {
                overflow-x: auto;
            }
        }
    </style>
    
</head>
<body>

<div class="container">
    <div class="header-top">
        <h1>ğŸ“Š å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆå®Œå…¨ãªç›´ç·šæŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ç‰ˆï¼‰</h1>
        <a id="sourceButton" href="https://www.alic.go.jp/operation/livestock/calf-report.html" target="_blank">è‚‰ç”¨å­ç‰›å–å¼•æƒ…å ±ã‚µã‚¤ãƒˆã¸</a>
    </div>
    
    <div class="input-area">
        <textarea id="dataInput" placeholder="ã“ã“ã«Excelã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„..."></textarea>
        <div class="controls">
            <div class="radio-group">
                <label>
                    <input type="radio" name="metricSelector" value="price">
                    å¹³å‡ä¾¡æ ¼ (å††)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="count" checked>
                    å–å¼•é ­æ•° (é ­)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="weight">
                    å¹³å‡ä½“é‡ (kg)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="age">
                    å¹³å‡æ—¥é½¢ (æ—¥)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="unitPrice">
                    1kgå˜ä¾¡ (å††)
                </label>
            </div>
        </div>
        <div id="errorMessage"></div>
    </div>
    
    <div id="maleAnalysisArea" class="analysis-pair-container" style="display: none;">
        <div id="maleTableSection" class="table-section"></div>
        <div id="maleGraphSection" class="graph-section">
            <h2>é›„ã®å¸‚å ´åˆ¥ãƒ»æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ• (<span class="graphMetricLabel">å–å¼•é ­æ•°</span>)</h2>
            <canvas id="maleChart"></canvas>
        </div>
    </div>
    
    <div id="femaleAnalysisArea" class="analysis-pair-container" style="display: none;">
        <div id="femaleTableSection" class="table-section"></div>
        <div id="femaleGraphSection" class="graph-section">
            <h2>é›Œã®å¸‚å ´åˆ¥ãƒ»æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ• (<span class="graphMetricLabel">å–å¼•é ­æ•°</span>)</h2>
            <canvas id="femaleChart"></canvas>
        </div>
    </div>
    
    <div id="totalAnalysisArea" class="analysis-pair-container" style="display: none;">
        <div id="totalTableSection" class="table-section"></div>
        <div id="totalGraphSection" class="graph-section">
            <h2>ç·åˆè¨ˆã®å¸‚å ´åˆ¥ãƒ»æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ• (<span class="graphMetricLabel">å–å¼•é ­æ•°</span>)</h2>
            <canvas id="totalChart"></canvas>
        </div>
    </div>
    
</div>

<script>
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨å®šæ•° ---
window.parsedData = {}; 
window.allMonths = []; 
window.selectedMarkets = new Set();
window.allMarketKeysInOrder = []; 
let chartInstances = {}; 

// METRICSå®šç¾©
const METRICS = {
    'count': { label: 'å–å¼•é ­æ•°', unit: 'é ­', axisLabel: 'é ­æ•°' },
    'weight': { label: 'å¹³å‡ä½“é‡', unit: 'kg', axisLabel: 'ä½“é‡ (kg)' },
    'age': { label: 'å¹³å‡æ—¥é½¢', unit: 'æ—¥', axisLabel: 'æ—¥é½¢ (æ—¥)' },
    'price': { label: 'å¹³å‡ä¾¡æ ¼', unit: 'å††', axisLabel: 'ä¾¡æ ¼ (å††)' },
    'unitPrice': { label: '1kgå˜ä¾¡', unit: 'å††', axisLabel: '1kgå˜ä¾¡ (å††)' },
};

// --- å¸‚å ´è­˜åˆ¥ç”¨ã®ãƒ‘ãƒ¬ãƒƒãƒˆ ---
const MARKET_COLORS = [
    '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', 
    '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', 
    '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', 
    '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'
];

const MARKET_POINT_STYLES = [
    'circle', 'triangle', 'rect', 'rectRot', 'cross', 'star', 'rectRounded'
];

function getMarketStyle(marketKey, globalIndex) {
    if (marketKey === 'ç·åˆè¨ˆ') {
        return {
            color: '#000000',    // é»’
            pointStyle: 'star',    // æ˜Ÿ
            dashPattern: [5, 5],   // ç‚¹ç·šã§å¼·èª¿
            borderWidth: 3
        };
    }
    
    const colorIndex = globalIndex % MARKET_COLORS.length;
    const shapeIndex = globalIndex % MARKET_POINT_STYLES.length;

    return {
        color: MARKET_COLORS[colorIndex],
        pointStyle: MARKET_POINT_STYLES[shapeIndex],
        dashPattern: [], 
        borderWidth: 2
    };
}


// --------------------------------------------------
// --- data-parser.js ã®å†…å®¹ (è§£æãƒ»å®Ÿæ•°æ ¼ç´ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£) ---
// --------------------------------------------------

function extractPrefAndMarket(line) {
    const parts = line.split(/[\t,]/).map(p => p.trim());
    let prefecture = '';
    let market = '';
    if (parts[0]) {
        prefecture = parts[0];
    }
    if (parts.length > 1 && parts[1]) {
        market = parts[1].replace(/\*|-/g, '').trim();
    }
    if (line.includes('ç·åˆè¨ˆ')) {
        prefecture = 'ç·åˆè¨ˆ';
        market = '';
    }
    return { prefecture, market };
}
function createMarketKey(prefecture, market) {
    if (prefecture === 'ç·åˆè¨ˆ') return 'ç·åˆè¨ˆ';
    return `${prefecture}_${market}`;
}
function isMarketHeaderLine(line) {
    if (line.includes("ãƒšãƒ¼ã‚¸") || line.includes("æœˆåˆ¥è‚‰ç”¨å­ç‰›å–å¼•çŠ¶æ³è¡¨") || line.includes("éƒ½é“åºœçœŒ") || line.includes("å“ç¨®ï¼š") || line.includes("åˆè¨ˆãƒ»å¹³å‡")) return false;
    const prefs = ["åŒ—æµ·é“", "é’æ£®", "å²©æ‰‹", "å®®åŸ", "ç§‹ç”°", "å±±å½¢", "ç¦å³¶", "èŒ¨åŸ", "æ ƒæœ¨", "ç¾¤é¦¬", "åŸ¼ç‰", "åƒè‘‰", "æ±äº¬", "ç¥å¥ˆå·", "æ–°æ½Ÿ", "å¯Œå±±", "çŸ³å·", "ç¦äº•", "å±±æ¢¨", "é•·é‡", "å²é˜œ", "é™å²¡", "æ„›çŸ¥", "ä¸‰é‡", "æ»‹è³€", "äº¬éƒ½", "å¤§é˜ª", "å…µåº«", "å¥ˆè‰¯", "å’Œæ­Œå±±", "é³¥å–", "å³¶æ ¹", "å²¡å±±", "åºƒå³¶", "å±±å£", "å¾³å³¶", "é¦™å·", "æ„›åª›", "é«˜çŸ¥", "ç¦å²¡", "ä½è³€", "é•·å´", "ç†Šæœ¬", "å¤§åˆ†", "å®®å´", "é¹¿å…å³¶", "æ²–ç¸„"];
    
    let parts = line.split(/\t/);
    parts = parts.filter(p => p.length > 0); 

    if (parts.length < 2 && line.includes(',')) {
        parts = line.split(/,/).map(p => p.trim());
        parts = parts.slice(0, 2).filter(p => p.length > 0);
    }
    
    if (line.includes("ç·åˆè¨ˆ") && !line.includes("åˆè¨ˆãƒ»å¹³å‡")) return true;
    
    const isPrefecture = prefs.some(p => parts[0] && parts[0].includes(p));
    const isMarket = parts[1] && (parts[1].includes('å¸‚å ´') || parts[1].includes('å®¶ç•œ'));

    if (line.includes("è¨ˆ") && !line.includes("å–å¼•é ­æ•°") && !line.includes("åˆè¨ˆãƒ»å¹³å‡")) return false; 
    
    return isPrefecture && isMarket;
}

function getMonthHeaderIndices(lines) {
    let headerLineIndex = -1;

    for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('éƒ½é“åºœçœŒ') && lines[i].includes('å¸‚å ´å') && lines[i].includes('æœˆ')) {
            headerLineIndex = i;
            break;
        }
    }
    
    if (headerLineIndex === -1) return { headerLineIndex: -1, headerMonths: [] };

    let fullHeaderParts = lines[headerLineIndex].split(/\t/);
    if (fullHeaderParts.length <= 1) fullHeaderParts = lines[headerLineIndex].split(/\s{2,}/);
    if (fullHeaderParts.length <= 1) fullHeaderParts = lines[headerLineIndex].split(/,/);

    const headerMonths = [];

    for (let i = 0; i < fullHeaderParts.length; i++) {
        let part = fullHeaderParts[i]; 
        if (!part) continue; 

        let trimmedPart = part.trim();
        
        if (trimmedPart.includes('åˆè¨ˆ') || trimmedPart.includes('å¹³å‡')) {
            continue; 
        }

        trimmedPart = trimmedPart.replace(/ï¼ˆ.*?ï¼‰/g,'').replace(/\s+/g,'');
        const digits = trimmedPart.replace(/[^0-9ï¼-ï¼™]/g, '');
        
        const half = digits.replace(/[ï¼-ï¼™]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
        
        const m = parseInt(half,10);

        if (!isNaN(m) && m >= 1 && m <= 12 && (trimmedPart.endsWith('æœˆ') || trimmedPart === String(m))) {
            headerMonths.push({ month: m, index: i, text: fullHeaderParts[i] });
        }
    }
    
    return { headerLineIndex, headerMonths };
}

function extractAllData(parts, headerMonths, currentMarketKey, gender, metricKey) {
    if (!metricKey || !currentMarketKey) return;

    let dataStartIndex = -1;

    const searchKeywords = [];
    if (gender === 'é›Œ') searchKeywords.push('é›Œ');
    else if (gender === 'é›„') searchKeywords.push('é›„');
    else if (gender === 'è¨ˆ') {
        searchKeywords.push('è¨ˆ');
        searchKeywords.push('å¹³å‡');
    }

    for (let i = 0; i < parts.length; i++) {
        if (searchKeywords.some(kw => parts[i].includes(kw))) {
            dataStartIndex = i + 1;
            break;
        }
    }

    if (dataStartIndex === -1 && headerMonths.length > 0) {
        dataStartIndex = headerMonths[0].index + 1; 
    }

    if (dataStartIndex === -1) return;

    headerMonths.forEach((mInfo, i) => {
        const currentDataIndex = dataStartIndex + i;
        
        let valueString = parts[currentDataIndex];
        
        if (valueString && valueString.trim() !== '') {
            // ã‚«ãƒ³ãƒã‚’é™¤å»ã—ã€ãƒã‚¤ãƒ•ãƒ³ã€ç©ºç™½ãªã©ã®éæ•°å€¤æ–‡å­—ã‚’æ’é™¤ã—ãŸæ–‡å­—åˆ—
            const cleanedValueString = valueString.replace(/,/g, '').trim();

            if (cleanedValueString === '-' || cleanedValueString === 'â€•' || cleanedValueString === '') {
                return; // ãƒã‚¤ãƒ•ãƒ³ã‚„ç©ºæ¬„ã¯ãƒ‡ãƒ¼ã‚¿ãªã—ã¨ã—ã¦ã‚¹ã‚­ãƒƒãƒ—
            }

            const val = parseFloat(cleanedValueString);
            
            if (!isNaN(val)) {
                // å–å¼•é ­æ•°('count')ã§å€¤ãŒ0ã®å ´åˆã¯ã€æ ¼ç´ã—ãªã„ï¼ˆæ¬ ææ‰±ã„ï¼‰
                if (metricKey === 'count' && val === 0) {
                    return; // 0é ­ã¯ãƒ‡ãƒ¼ã‚¿ãªã—ã¨è¦‹ãªã™
                }
                
                // ãƒ‡ãƒ¼ã‚¿æ ¼ç´
                if (!window.parsedData[currentMarketKey]) window.parsedData[currentMarketKey] = {};
                if (!window.parsedData[currentMarketKey][gender]) window.parsedData[currentMarketKey][gender] = {};
                
                if (!window.parsedData[currentMarketKey][gender][mInfo.index]) window.parsedData[currentMarketKey][gender][mInfo.index] = {};
                
                window.parsedData[currentMarketKey][gender][mInfo.index][metricKey] = val;
            }
        }
    });
}

function processData() {
    const rawInput = document.getElementById('dataInput').value;
    const errorDiv = document.getElementById('errorMessage'); 
    
    const areas = ['male', 'female', 'total'];

    if (errorDiv) errorDiv.textContent = "";
    areas.forEach(a => {
        const graphElem = document.getElementById(`${a}AnalysisArea`);
        if (graphElem) graphElem.style.display = 'none';
    });

    window.parsedData = {};
    window.allMonths = []; 
    window.allMarketKeysInOrder = []; 
    window.selectedMarkets.clear(); 

    if (!rawInput.trim()) {
        return;
    }

    const lines = rawInput.split('\n')
                          .map(line => line.replace(/\r/g,'').trim())
                          .filter(line => line.length > 0);
    
    const { headerLineIndex, headerMonths } = getMonthHeaderIndices(lines);

    if (headerLineIndex === -1) {
        if (errorDiv) errorDiv.textContent = "ã‚¨ãƒ©ãƒ¼: ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œï¼ˆéƒ½é“åºœçœŒ, å¸‚å ´å, æœˆã‚’å«ã‚€è¡Œï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ­£ã—ã„å½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚";
        return;
    }
    
    window.allMonths = headerMonths;
    
    let currentMarketKey = null;
    let currentMetric = null;

    for (let i = headerLineIndex + 1; i < lines.length; i++) {
        const line = lines[i];

        if (line.includes("ãƒšãƒ¼ã‚¸ï¼š") || line.includes("ã€Š") || line.includes("å“ç¨®ï¼š") || line.includes("å–å¼•æœˆ") || line.includes("åˆè¨ˆãƒ»å¹³å‡")) continue;

        const isHeader = isMarketHeaderLine(line);

        if (isHeader) {
            const names = extractPrefAndMarket(line);
            const currentPrefName = names.prefecture;
            const currentMarketName = names.market;
            
            if (currentMarketName === 'çœŒåˆè¨ˆ') {
                currentMarketKey = null; 
                currentMetric = null;
                continue;
            }

            currentMarketKey = createMarketKey(currentPrefName, currentMarketName);
            if (!window.parsedData[currentMarketKey]) window.parsedData[currentMarketKey] = { 'é›„': {}, 'é›Œ': {}, 'è¨ˆ': {} };
            
            if (!window.allMarketKeysInOrder.includes(currentMarketKey)) {
                window.allMarketKeysInOrder.push(currentMarketKey);
            }

            currentMetric = null; 
            continue; 
        }

        if (!currentMarketKey) continue; 

        if (line.includes("å–å¼•é ­æ•°")) currentMetric = "count";
        else if (line.includes("å¹³å‡ä¾¡æ ¼")) currentMetric = "price";
        else if (line.includes("å¹³å‡ä½“é‡")) currentMetric = "weight";
        else if (line.includes("å¹³å‡æ—¥é½¢")) currentMetric = "age";
        else if (line.includes("ï¼‘ãå˜ä¾¡") || line.includes("1kgå˜ä¾¡")) currentMetric = "unitPrice";
        
        const isAverageLine = line.trim().startsWith('å¹³å‡');
        
        if (!currentMetric && !isAverageLine) continue;

        let parts = line.split(/\t/);
        if (parts.length <= 1) parts = line.split(/\s{2,}/);
        if (parts.length <= 1) parts = line.split(/,/);
        
        const hasFemale = line.includes("é›Œ");
        const hasMale = line.includes("é›„");
        
        const isCountTotalLine = currentMetric === 'count' && (line.includes("è¨ˆ") || line.includes("åˆè¨ˆ")) && !line.includes("å¹³å‡");
        const isMetricTotalOrAverageLine = (currentMetric !== 'count' && (line.includes("è¨ˆ") || line.includes("å¹³å‡"))) || isAverageLine;

        
        if (hasFemale) extractAllData(parts, headerMonths, currentMarketKey, 'é›Œ', currentMetric);
        if (hasMale) extractAllData(parts, headerMonths, currentMarketKey, 'é›„', currentMetric);
        
        if (isCountTotalLine || isMetricTotalOrAverageLine) {
            let targetMetric = currentMetric;
            
            if (isAverageLine && !currentMetric) { 
                for (let j = i - 1; j >= headerLineIndex; j--) {
                    if (lines[j].includes("å¹³å‡ä½“é‡")) { targetMetric = "weight"; break; }
                    if (lines[j].includes("å¹³å‡ä¾¡æ ¼")) { targetMetric = "price"; break; }
                    if (lines[j].includes("å¹³å‡æ—¥é½¢")) { targetMetric = "age"; break; }
                    if (lines[j].includes("å–å¼•é ­æ•°")) { targetMetric = "count"; break; }
                }
            }

            if (targetMetric) extractAllData(parts, headerMonths, currentMarketKey, 'è¨ˆ', targetMetric);
        }
    }

    if (Object.keys(window.parsedData).length === 0) {
        if (errorDiv) errorDiv.textContent = "æœ‰åŠ¹ãªå¸‚å ´ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
        return;
    }

    if (window.allMonths.length > 0) {
        if (window.parsedData['ç·åˆè¨ˆ']) {
            window.selectedMarkets.add('ç·åˆè¨ˆ');
        }
        window.allMarketKeysInOrder.forEach(key => {
            if (key.startsWith('åŒ—æµ·é“') || key.startsWith('å³¶æ ¹')) {
                 window.selectedMarkets.add(key);
            }
        });
        if (window.selectedMarkets.size === 0 && window.allMarketKeysInOrder.length > 0) {
            window.selectedMarkets.add(window.allMarketKeysInOrder[0]);
        }
    }

    renderAllAnalysisSections();
}

// --------------------------------------------------
// --- ui-renderer.js ã®å†…å®¹ (ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£) ---
// --------------------------------------------------

function formatValue(value) { 
    const selectedMetric = document.querySelector('input[name="metricSelector"]:checked').value;
    
    // value === 0 ã®ãƒã‚§ãƒƒã‚¯ã‚’ã“ã“ã§ã‚‚è¡Œã„ã€0ã®å ´åˆã¯ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºã‚’ãƒã‚¤ãƒ•ãƒ³ã«çµ±ä¸€
    if (value === undefined || value === null || (selectedMetric === 'count' && value === 0)) return `-`;
    
    let formattedValue;

    if (selectedMetric === 'weight' || selectedMetric === 'age') {
        formattedValue = parseFloat(value).toFixed(1).toLocaleString();
    } else {
        formattedValue = Math.round(parseFloat(value)).toLocaleString();
    }
    
    return `<span class="score-value">${formattedValue}</span>`;
}

function renderTable(gender, containerId, analysisAreaId) {
    const container = document.getElementById(containerId);
    const analysisArea = document.getElementById(analysisAreaId);
    container.innerHTML = "";
    
    const selectedMetric = document.querySelector('input[name="metricSelector"]:checked').value;
    const metricInfo = METRICS[selectedMetric];

    const orderedMarketKeys = [];
    const totalKey = 'ç·åˆè¨ˆ';

    // ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹å¸‚å ´ã®ã¿ã‚’æŠ½å‡º
    window.allMarketKeysInOrder.forEach(k => {
        if (k !== totalKey && window.allMonths.some(mInfo => window.parsedData[k][gender] && window.parsedData[k][gender][mInfo.index] && window.parsedData[k][gender][mInfo.index][selectedMetric] !== undefined && window.parsedData[k][gender][mInfo.index][selectedMetric] !== null)) {
            orderedMarketKeys.push(k);
        }
    });

    if (window.parsedData[totalKey] && window.allMonths.some(mInfo => window.parsedData[totalKey][gender] && window.parsedData[totalKey][gender][mInfo.index] && window.parsedData[totalKey][gender][mInfo.index][selectedMetric] !== undefined && window.parsedData[totalKey][gender][mInfo.index][selectedMetric] !== null)) {
        orderedMarketKeys.push(totalKey);
    }


    if (orderedMarketKeys.length === 0) {
        analysisArea.style.display = 'none'; 
        return; 
    }

    analysisArea.style.display = 'grid'; 

    let title = `ã€${gender}ã€‘ ${metricInfo.label} ã‚¯ãƒ­ã‚¹è¡¨`;
    
    let html = `
    <div class="table-header-controls">
        <h2>${title}</h2>
        <div id="marketSelectionControls">
            <button onclick="uncheckAllMarkets()">å…¨ã¦ã®å¸‚å ´ã‚’éè¡¨ç¤º</button>
        </div>
    </div>
    <table>
        <thead>
            <tr>
                <th class="checkbox-cell">â˜‘</th>
                <th class="pref-col">éƒ½é“åºœçœŒ</th>
                <th class="market-col">å¸‚å ´å</th>`;
    
    window.allMonths.forEach(mInfo => {
        html += `<th>${mInfo.month}æœˆ</th>`;
    });

    html += `</tr></thead><tbody>`;
    
    orderedMarketKeys.forEach(mKey => {
        const isTotal = mKey === 'ç·åˆè¨ˆ';
        const rowClass = isTotal ? 'class="total-row"' : '';
        
        let prefectureName = isTotal ? '---' : mKey.split('_')[0];
        let marketName = isTotal ? 'ç·åˆè¨ˆ' : mKey.split('_')[1];
        
        const checked = window.selectedMarkets.has(mKey) ? 'checked' : '';
        const checkbox = `<input type="checkbox" data-market-key="${mKey}" ${checked} onchange="handleMarketSelection(this)">`;
        
        html += `<tr ${rowClass}>
            <td class="checkbox-cell">${checkbox}</td>
            <td class="pref-col">${prefectureName}</td>
            <td class="market-col">${marketName}</td>`;
        
        window.allMonths.forEach(mInfo => {
            const value = window.parsedData[mKey][gender]?.[mInfo.index]?.[selectedMetric];
            html += `<td>${formatValue(value)}</td>`;
        });
        
        html += `</tr>`;
    });
    html += `</tbody></table>`;
    container.innerHTML = html;
}

// Chart.jsã‚’ä½¿ã£ãŸæŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ã®æç”»
function updateGraph(gender, canvasId, analysisAreaId) {
    const selectedMetric = document.querySelector('input[name="metricSelector"]:checked').value;
    const metricInfo = METRICS[selectedMetric];
    
    const labelElement = document.getElementById(canvasId).parentElement.querySelector('.graphMetricLabel');
    if (labelElement) {
        labelElement.textContent = metricInfo.label;
    }
    
    const datasets = [];
    
    if (window.selectedMarkets.size > 0) {
        
        const marketKeysToDraw = Array.from(window.selectedMarkets).sort((a, b) => {
            if (a === 'ç·åˆè¨ˆ') return 1;
            if (b === 'ç·åˆè¨ˆ') return -1;
            return a.localeCompare(b, 'ja');
        });

        marketKeysToDraw.forEach(marketKey => {
            const marketName = marketKey === 'ç·åˆè¨ˆ' ? 'ç·åˆè¨ˆ' : marketKey.split('_')[1];
            const prefName = marketKey === 'ç·åˆè¨ˆ' ? '' : marketKey.split('_')[0];
            const isTotalKey = marketKey === 'ç·åˆè¨ˆ';
            
            const dataPoints = [];
            let hasData = false;
            
            window.allMonths.forEach((mInfo) => {
                const month = mInfo.month; 
                const rawValue = window.parsedData[marketKey]?.[gender]?.[mInfo.index]?.[selectedMetric];
                
                // ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã«è¿½åŠ ï¼ˆrawValueãŒundefined/null/count=0ã§ã¯ãªã„å ´åˆï¼‰
                if (rawValue !== undefined && rawValue !== null) {
                    if (!(selectedMetric === 'count' && rawValue === 0)) {
                        dataPoints.push({ x: month, y: rawValue });
                        hasData = true;
                    }
                }
            });

            // ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’æœˆé † (X) ã§ã‚½ãƒ¼ãƒˆã™ã‚‹
            dataPoints.sort((a, b) => a.x - b.x);

            if (hasData) {
                const globalIndex = window.allMarketKeysInOrder.indexOf(marketKey);
                const safeIndex = globalIndex >= 0 ? globalIndex : 0;
                
                const style = getMarketStyle(marketKey, safeIndex);
                
                datasets.push({
                    label: `${marketName}${isTotalKey ? '' : ` (${prefName})`}`,
                    
                    data: dataPoints, 
                    
                    backgroundColor: style.color,
                    borderColor: style.color, 
                    pointRadius: 6, 
                    pointStyle: style.pointStyle, 
                    borderWidth: style.borderWidth, 
                    borderDash: style.dashPattern, 

                    showLine: true, 
                    tension: 0, // â˜… ä¿®æ­£: ç›´ç·šã«ã™ã‚‹ãŸã‚ã«tensionã‚’0ã«å›ºå®š
                    fill: false,
                    type: 'line',
                    
                    spanGaps: false,
                    
                    // â˜… ä¿®æ­£: ä¸è¦ãªè£œé–“è¨­å®šã‚„ç’°çŠ¶ã®è¨­å®šã‚’å‰Šé™¤ã—ã€ç›´ç·šã‚°ãƒ©ãƒ•ã‚’ç¢ºå®Ÿã«ã™ã‚‹
                    cubicInterpolationMode: 'linear', 
                    normalized: false 
                });
            }
        });
    }

    const ctx = document.getElementById(canvasId);
    if (!ctx) return; 

    const ctx_2d = ctx.getContext('2d');
    
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx_2d, {
        type: 'line', 
        data: {
            labels: [], 
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top', labels: { font: { size: 12 }, usePointStyle: true } },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const xValue = context[0].parsed.x; 
                            return xValue + 'æœˆ'; 
                        },
                        label: function(context) {
                            const label = context.dataset.label || '';
                            let yValue = context.parsed.y;
                            
                            const metricLabel = `(${metricInfo.label})`;

                            if (selectedMetric === 'weight' || selectedMetric === 'age') {
                                yValue = parseFloat(yValue).toFixed(1).toLocaleString();
                            } else {
                                yValue = Math.round(yValue).toLocaleString();
                            }
                            return `${label} ${metricLabel}: ${yValue}${metricInfo.unit}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    // linearè»¸ï¼ˆæ•°å€¤è»¸ï¼‰ã§æœˆã‚’æ‰±ã†
                    type: 'linear', 
                    title: { display: true, text: 'é–‹å‚¬æœˆ (Xè»¸)' },
                    min: 1, 
                    max: 12, 
                    ticks: {
                        stepSize: 1, 
                        callback: function(value) { 
                            if (Number.isInteger(value) && value >= 1 && value <= 12) {
                                return value + 'æœˆ';
                            }
                            return ''; 
                        }
                    },
                    // ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹Xåº§æ¨™ã®ã¿ã‚’è€ƒæ…®
                    bounds: 'ticks', 
                    grid: { drawOnChartArea: true } 
                },
                y: {
                    title: { display: true, text: metricInfo.axisLabel + ' (Yè»¸)' },
                    // Yè»¸ã®æœ€å°å€¤è¨­å®šã‚’å‰Šé™¤ï¼ˆè‡ªå‹•èª¿æ•´ã«ä»»ã›ã‚‹ï¼‰
                    ticks: {
                        callback: function(value) { 
                            if (selectedMetric === 'weight' || selectedMetric === 'age') {
                                return value.toFixed(1) + metricInfo.unit;
                            } else {
                                return value.toLocaleString() + metricInfo.unit; 
                            }
                        }
                    }
                }
            }
        }
    });
}

function updateAllGraphs() {
    updateGraph('é›„', 'maleChart', 'maleAnalysisArea');
    updateGraph('é›Œ', 'femaleChart', 'femaleAnalysisArea');
    updateGraph('è¨ˆ', 'totalChart', 'totalAnalysisArea');
}

function renderAllAnalysisSections() {
    renderTable('é›„', 'maleTableSection', 'maleAnalysisArea');
    renderTable('é›Œ', 'femaleTableSection', 'femaleAnalysisArea');
    renderTable('è¨ˆ', 'totalTableSection', 'totalAnalysisArea');
    updateAllGraphs(); 
}


function handleMarketSelection(checkbox) {
    const marketKey = checkbox.getAttribute('data-market-key');
    if (checkbox.checked) {
        window.selectedMarkets.add(marketKey);
    } else {
        window.selectedMarkets.delete(marketKey);
    }
    document.querySelectorAll(`input[data-market-key="${marketKey}"]`).forEach(cb => {
        cb.checked = checkbox.checked;
    });
    renderAllAnalysisSections(); 
}

function uncheckAllMarkets() {
    window.selectedMarkets.clear();
    document.querySelectorAll(`input[type="checkbox"][data-market-key]`).forEach(cb => {
        cb.checked = false;
    });
    renderAllAnalysisSections();
}

function handleMetricChange() {
    renderAllAnalysisSections();
}


// --- åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ ---
window.onload = function() {
    const dataInput = document.getElementById('dataInput');
    const metricSelectors = document.querySelectorAll('input[name="metricSelector"]');

    dataInput.addEventListener('input', processData);
    metricSelectors.forEach(radio => {
        radio.addEventListener('change', handleMetricChange);
    });
    
    window.handleMarketSelection = handleMarketSelection;
    window.uncheckAllMarkets = uncheckAllMarkets;

    const defaultRadio = document.querySelector('input[name="metricSelector"][value="count"]');
    if (defaultRadio) {
        defaultRadio.checked = true;
    }
    
    processData();
};
</script>

</body>
</html>
