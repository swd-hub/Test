<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆè¡¨ã¨ã‚°ãƒ©ãƒ•ï¼‰ä¿®æ­£ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; padding: 20px; background-color: #f4f6f9; color: #333; }
        h1 { font-size: 1.4rem; margin-bottom: 10px; border-bottom: 2px solid #ddd; padding-bottom: 10px; }

        .container { 
            max-width: 1800px; 
            margin: 0 auto; 
            background: #fff; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
        }

        .header-top { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .header-top h1 { margin: 0; flex: 1; min-width: 300px; } 
        #sourceButton {
            padding: 10px 20px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
        }
        #sourceButton:hover { background-color: #5a6268; }

        .input-area { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
        textarea { width: 100%; height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px; }
        .controls { margin-top: 15px; display: flex; gap: 30px; align-items: center; background: #eef; padding: 15px; border-radius: 5px; flex-wrap: wrap; }
        .radio-group label { margin-right: 15px; font-weight: bold; }
        #errorMessage { color: red; font-weight: bold; margin-top: 10px; }


        .analysis-pair-container {
            margin-top: 30px;
            padding: 20px 0;
            border-top: 3px solid #6c757d;
            
            display: grid;
            grid-template-columns: minmax(40%, 700px) 1fr; /* è¡¨ã¨ã‚°ãƒ©ãƒ•ã‚’ä¸¦åˆ—è¡¨ç¤º */
            gap: 20px;
        }

        .table-section {
            background: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-radius: 8px;
            overflow-x: auto;
            max-height: 800px;
        }
        .table-section h2 { 
            background-color: #343a40; 
            color: white; 
            padding: 10px; 
            margin: 0; 
            font-size: 1.1rem; 
            border-radius: 8px 8px 0 0;
            text-align: center;
        }

        table { 
            width: 100%; 
            min-width: 800px;
            border-collapse: collapse; 
            font-size: 13px; 
            background: white; 
        }
        th, td { border: 1px solid #ddd; padding: 5px; text-align: center; } 
        th { 
            background-color: #f8f9fa; 
            color: #333; 
            font-weight: bold; 
        }
        td { white-space: nowrap; }

        tr:nth-child(even) { background-color: #fcfcfc; }
        tr:hover { background-color: #f1f1f1; }

        .checkbox-cell { width: 40px; } 
        .pref-col { text-align: left; font-weight: normal; width: 80px; }
        .market-col { text-align: left; font-weight: bold; width: 150px; }
        
        .total-row { background-color: #e9ecef; font-weight: bold; }
        .score-value { font-weight: bold; color: #000; } 


        .graph-section {
            padding: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-height: 800px;
            min-height: 600px; 
        }
        .graph-section h2 {
            font-size: 1.1rem;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 10px;
            margin-top: 0;
        }
        canvas { height: 100%; width: 100%; }

        @media (max-width: 1200px) {
            .analysis-pair-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .table-section {
                overflow-x: auto;
            }
        }
    </style>
    
</head>
<body>

<div class="container">
    <div class="header-top">
        <h1>ğŸ“Š å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆè¡¨ã¨æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ï¼‰</h1>
        <a id="sourceButton" href="https://www.alic.go.jp/operation/livestock/calf-report.html" target="_blank">è‚‰ç”¨å­ç‰›å–å¼•æƒ…å ±ã‚µã‚¤ãƒˆã¸</a>
    </div>
    
    <div class="input-area">
        <textarea id="dataInput" placeholder="ã“ã“ã«Excelã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„..."></textarea>
        <div class="controls">
            <div class="radio-group">
                <label>
                    <input type="radio" name="metricSelector" value="count" checked>
                    å–å¼•é ­æ•° (é ­)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="weight">
                    å¹³å‡ä½“é‡ (kg)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="age">
                    å¹³å‡æ—¥é½¢ (æ—¥)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="price">
                    å¹³å‡ä¾¡æ ¼ (å††)
                </label>
                <label>
                    <input type="radio" name="metricSelector" value="unitPrice">
                    1kgå˜ä¾¡ (å††)
                </label>
            </div>
        </div>
        <div id="errorMessage"></div>
    </div>
    
    <div id="maleAnalysisArea" class="analysis-pair-container" style="display: none;">
        <div id="maleTableSection" class="table-section"></div>
        <div id="maleGraphSection" class="graph-section">
            <h2>é›„ã®å¸‚å ´åˆ¥ãƒ»æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ• (<span class="graphMetricLabel">å–å¼•é ­æ•°</span>)</h2>
            <canvas id="maleChart"></canvas>
        </div>
    </div>
    
    <div id="femaleAnalysisArea" class="analysis-pair-container" style="display: none;">
        <div id="femaleTableSection" class="table-section"></div>
        <div id="femaleGraphSection" class="graph-section">
            <h2>é›Œã®å¸‚å ´åˆ¥ãƒ»æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ• (<span class="graphMetricLabel">å–å¼•é ­æ•°</span>)</h2>
            <canvas id="femaleChart"></canvas>
        </div>
    </div>
    
    <div id="totalAnalysisArea" class="analysis-pair-container" style="display: none;">
        <div id="totalTableSection" class="table-section"></div>
        <div id="totalGraphSection" class="graph-section">
            <h2>ç·åˆè¨ˆã®å¸‚å ´åˆ¥ãƒ»æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ• (<span class="graphMetricLabel">å–å¼•é ­æ•°</span>)</h2>
            <canvas id="totalChart"></canvas>
        </div>
    </div>
    
</div>

<script>
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨å®šæ•° ---
window.parsedData = {}; 
window.allMonths = []; 
window.selectedMarkets = new Set();
window.allMarketKeysInOrder = []; 
let chartInstances = {}; 

// METRICSå®šç¾©
const METRICS = {
    'count': { label: 'å–å¼•é ­æ•°', unit: 'é ­', axisLabel: 'é ­æ•°' },
    'weight': { label: 'å¹³å‡ä½“é‡', unit: 'kg', axisLabel: 'ä½“é‡ (kg)' },
    'age': { label: 'å¹³å‡æ—¥é½¢', unit: 'æ—¥', axisLabel: 'æ—¥é½¢ (æ—¥)' },
    'price': { label: 'å¹³å‡ä¾¡æ ¼', unit: 'å††', axisLabel: 'ä¾¡æ ¼ (å††)' },
    'unitPrice': { label: '1kgå˜ä¾¡', unit: 'å††', axisLabel: '1kgå˜ä¾¡ (å††)' },
};

// --- æ€§åˆ¥ã«ã‚ˆã‚‹è‰²ã€å›³å½¢ã€ç·šç¨®ã®çµ±ä¸€å®šç¾© ---
const GENDER_STYLES = {
    'é›„': { 
        color: 'rgba(54, 162, 235, 1)', // é’ 
        pointStyle: 'circle', 
        dashPattern: [] 
    },
    'é›Œ': { 
        color: 'rgba(255, 99, 132, 1)', // èµ¤ 
        pointStyle: 'triangle', 
        dashPattern: [5, 5] 
    },
    'è¨ˆ': { 
        color: 'rgba(75, 192, 192, 1)', // ç·‘ 
        pointStyle: 'rect', 
        dashPattern: [1, 5] 
    },
    'ç·åˆè¨ˆ': { 
        color: 'rgba(108, 117, 125, 1)', // ç°è‰² 
        pointStyle: 'star', 
        dashPattern: [2, 2],
        override: true
    } 
};


// --------------------------------------------------
// --- data-parser.js ã®å†…å®¹ (è§£æãƒ»å®Ÿæ•°æ ¼ç´ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£) ---
// --------------------------------------------------

function extractPrefAndMarket(line) {
    const parts = line.split(/[\t,]/).map(p => p.trim());
    let prefecture = '';
    let market = '';
    if (parts[0]) {
        prefecture = parts[0];
    }
    if (parts.length > 1 && parts[1]) {
        market = parts[1].replace(/\*|-/g, '').trim();
    }
    if (line.includes('ç·åˆè¨ˆ')) {
        prefecture = 'ç·åˆè¨ˆ';
        market = '';
    }
    return { prefecture, market };
}
function createMarketKey(prefecture, market) {
    if (prefecture === 'ç·åˆè¨ˆ') return 'ç·åˆè¨ˆ';
    return `${prefecture}_${market}`;
}
function isMarketHeaderLine(line) {
    if (line.includes("ãƒšãƒ¼ã‚¸") || line.includes("æœˆåˆ¥è‚‰ç”¨å­ç‰›å–å¼•çŠ¶æ³è¡¨") || line.includes("éƒ½é“åºœçœŒ") || line.includes("å“ç¨®ï¼š") || line.includes("åˆè¨ˆãƒ»å¹³å‡")) return false;
    const prefs = ["åŒ—æµ·é“", "é’æ£®", "å²©æ‰‹", "å®®åŸ", "ç§‹ç”°", "å±±å½¢", "ç¦å³¶", "èŒ¨åŸ", "æ ƒæœ¨", "ç¾¤é¦¬", "åŸ¼ç‰", "åƒè‘‰", "æ±äº¬", "ç¥å¥ˆå·", "æ–°æ½Ÿ", "å¯Œå±±", "çŸ³å·", "ç¦äº•", "å±±æ¢¨", "é•·é‡", "å²é˜œ", "é™å²¡", "æ„›çŸ¥", "ä¸‰é‡", "æ»‹è³€", "äº¬éƒ½", "å¤§é˜ª", "å…µåº«", "å¥ˆè‰¯", "å’Œæ­Œå±±", "é³¥å–", "å³¶æ ¹", "å²¡å±±", "åºƒå³¶", "å±±å£", "å¾³å³¶", "é¦™å·", "æ„›åª›", "é«˜çŸ¥", "ç¦å²¡", "ä½è³€", "é•·å´", "ç†Šæœ¬", "å¤§åˆ†", "å®®å´", "é¹¿å…å³¶", "æ²–ç¸„"];
    
    let parts = line.split(/\t/);
    parts = parts.filter(p => p.length > 0); 

    if (parts.length < 2 && line.includes(',')) {
        parts = line.split(/,/).map(p => p.trim());
        parts = parts.slice(0, 2).filter(p => p.length > 0);
    }
    
    if (line.includes("ç·åˆè¨ˆ") && !line.includes("åˆè¨ˆãƒ»å¹³å‡")) return true;
    
    const isPrefecture = prefs.some(p => parts[0] && parts[0].includes(p));
    const isMarket = parts[1] && (parts[1].includes('å¸‚å ´') || parts[1].includes('å®¶ç•œ'));

    if (line.includes("è¨ˆ") && !line.includes("å–å¼•é ­æ•°") && !line.includes("åˆè¨ˆãƒ»å¹³å‡")) return false; 
    
    return isPrefecture && isMarket;
}

function getMonthHeaderIndices(lines) {
    let headerLineIndex = -1;

    for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('éƒ½é“åºœçœŒ') && lines[i].includes('å¸‚å ´å') && lines[i].includes('æœˆ')) {
            headerLineIndex = i;
            break;
        }
    }
    
    if (headerLineIndex === -1) return { headerLineIndex: -1, headerMonths: [] };

    let fullHeaderParts = lines[headerLineIndex].split(/\t/);
    if (fullHeaderParts.length <= 1) fullHeaderParts = lines[headerLineIndex].split(/\s{2,}/);
    if (fullHeaderParts.length <= 1) fullHeaderParts = lines[headerLineIndex].split(/,/);

    const headerMonths = [];

    for (let i = 0; i < fullHeaderParts.length; i++) {
        let part = fullHeaderParts[i]; 
        if (!part) continue; 

        let trimmedPart = part.trim();
        
        // ã€Œåˆè¨ˆã€ã¾ãŸã¯ã€Œå¹³å‡ã€ã‚’å«ã‚€åˆ—ã¯ã€æœˆãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦é™¤å¤–ã™ã‚‹
        if (trimmedPart.includes('åˆè¨ˆ') || trimmedPart.includes('å¹³å‡')) {
            continue; 
        }

        trimmedPart = trimmedPart.replace(/ï¼ˆ.*?ï¼‰/g,'').replace(/\s+/g,'');
        const digits = trimmedPart.replace(/[^0-9ï¼-ï¼™]/g, '');
        
        const half = digits.replace(/[ï¼-ï¼™]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
        
        const m = parseInt(half,10);

        // 1æœˆã‹ã‚‰12æœˆã®æœˆã¨ã—ã¦èªè­˜ã•ã‚ŒãŸå ´åˆ
        if (!isNaN(m) && m >= 1 && m <= 12 && (trimmedPart.endsWith('æœˆ') || trimmedPart === String(m))) {
            // i ã¯ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚­ãƒ¼ã¨ã—ã¦é‡è¦ï¼ˆ12æœˆãŒ2å›ç™»å ´ã—ãŸå ´åˆã®å¯¾ç­–ï¼‰
            headerMonths.push({ month: m, index: i, text: fullHeaderParts[i] });
        }
    }
    
    return { headerLineIndex, headerMonths };
}

function extractAllData(parts, headerMonths, currentMarketKey, gender, metricKey) {
    if (!metricKey || !currentMarketKey) return;

    // ã€é‡è¦ä¿®æ­£ã€‘ãƒ‡ãƒ¼ã‚¿é–‹å§‹ä½ç½®ã‚’ã€Œçµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ã§ã¯ãªãã€Œã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰ã®ç›¸å¯¾ä½ç½®ã€ã§ç‰¹å®šã™ã‚‹
    // ã“ã‚Œã«ã‚ˆã‚Šãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã¨ãƒ‡ãƒ¼ã‚¿è¡Œã§ã‚¿ãƒ–ã®æ•°ãŒé•ã£ã¦ã‚‚ã‚ºãƒ¬ãªããªã‚‹
    let dataStartIndex = -1;

    // è¡Œã®ä¸­ã‹ã‚‰ã‚¢ãƒ³ã‚«ãƒ¼ã¨ãªã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆé›Œ, é›„, å¹³å‡ãªã©ï¼‰ã‚’æ¢ã™
    const searchKeywords = [];
    if (gender === 'é›Œ') searchKeywords.push('é›Œ');
    else if (gender === 'é›„') searchKeywords.push('é›„');
    else if (gender === 'è¨ˆ') {
        searchKeywords.push('è¨ˆ');
        searchKeywords.push('å¹³å‡');
        // ã¾ã‚Œã«ã€Œå¹³å‡ä¾¡æ ¼ã€è¡Œãªã©ã§ã‚¢ãƒ³ã‚«ãƒ¼ãŒç„¡ã„å ´åˆã‚‚ã‚ã‚‹ãŒã€ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä¸Š 'å¹³å‡' ãŒã‚ã‚‹ã¯ãš
    }

    // ã‚¢ãƒ³ã‚«ãƒ¼æ¢ç´¢
    for (let i = 0; i < parts.length; i++) {
        if (searchKeywords.some(kw => parts[i].includes(kw))) {
            dataStartIndex = i + 1; // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®æ¬¡ã®åˆ—ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ãŒå§‹ã¾ã‚‹ã¨ã¿ãªã™
            break;
        }
    }

    // ã‚¢ãƒ³ã‚«ãƒ¼ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ä½ç½®ã«åŸºã¥ãæ¨å®šï¼‰
    if (dataStartIndex === -1 && headerMonths.length > 0) {
        // é€šå¸¸ã€ãƒ‡ãƒ¼ã‚¿ã¯ãƒ˜ãƒƒãƒ€ãƒ¼ã‚ˆã‚Š1ã¤å³ï¼ˆæŒ‡æ¨™åˆ—åˆ†ï¼‰ã«ã‚ºãƒ¬ã‚‹ã“ã¨ãŒå¤šã„ãŒã€å®‰å…¨ç­–ã¨ã—ã¦ãƒ˜ãƒƒãƒ€ãƒ¼ã¨åŒã˜ã‹+1ã‚’è©¦ã™
        // ã“ã“ã§ã¯å˜ç´”ã«ãƒ˜ãƒƒãƒ€ãƒ¼ã®æœ€åˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹+1ã‚’ä»®å®šï¼ˆå¤šãã®å¸‚å ´ãƒ‡ãƒ¼ã‚¿å½¢å¼ã«é©åˆï¼‰
        dataStartIndex = headerMonths[0].index + 1; 
    }

    if (dataStartIndex === -1) return;

    // æŠ½å‡ºå‡¦ç†
    headerMonths.forEach((mInfo, i) => {
        // headerMonthsã¯å·¦ã‹ã‚‰é †ã«ä¸¦ã‚“ã§ã„ã‚‹ã®ã§ã€dataStartIndexã‹ã‚‰ +i ã—ã¦ã„ãï¼ˆã“ã‚Œã§é€£ç¶šã™ã‚‹æœˆã‚’å–å¾—ï¼‰
        // ãƒ˜ãƒƒãƒ€ãƒ¼ã§ã€Œåˆè¨ˆãƒ»å¹³å‡ã€ã‚’é™¤å¤–ã—ã¦ã„ã‚‹ã®ã§ã€ãƒ«ãƒ¼ãƒ—ã¯ãƒ‡ãƒ¼ã‚¿è¡Œã®ã€Œåˆè¨ˆãƒ»å¹³å‡ã€ã®æ‰‹å‰ã§æ­¢ã¾ã‚‹
        const currentDataIndex = dataStartIndex + i;
        
        let value = parts[currentDataIndex];
        
        if (value && value.trim() !== '') {
            const val = parseFloat(value.replace(/,/g, '').trim());
            if (!isNaN(val)) {
                if (!window.parsedData[currentMarketKey]) window.parsedData[currentMarketKey] = {};
                if (!window.parsedData[currentMarketKey][gender]) window.parsedData[currentMarketKey][gender] = {};
                
                // ã€é‡è¦ä¿®æ­£ã€‘mInfo.month (æœˆæ•°) ã§ã¯ãªã mInfo.index (ä¸€æ„ãªID) ã‚’ã‚­ãƒ¼ã«ã™ã‚‹
                // ã“ã‚Œã«ã‚ˆã‚Šã€Œ12æœˆã€ãŒå¹´ã¾ãŸãã§2å›ç™»å ´ã—ã¦ã‚‚ä¸Šæ›¸ãã•ã‚Œãªã„
                if (!window.parsedData[currentMarketKey][gender][mInfo.index]) window.parsedData[currentMarketKey][gender][mInfo.index] = {};
                
                window.parsedData[currentMarketKey][gender][mInfo.index][metricKey] = val;
            }
        }
    });
}

function processData() {
    const rawInput = document.getElementById('dataInput').value;
    const errorDiv = document.getElementById('errorMessage'); 
    
    const areas = ['male', 'female', 'total'];

    if (errorDiv) errorDiv.textContent = "";
    areas.forEach(a => {
        const graphElem = document.getElementById(`${a}AnalysisArea`);
        if (graphElem) graphElem.style.display = 'none';
    });

    window.parsedData = {};
    window.allMonths = []; 
    window.allMarketKeysInOrder = []; 
    window.selectedMarkets.clear(); 

    if (!rawInput.trim()) {
        return;
    }

    const lines = rawInput.split('\n')
                          .map(line => line.replace(/\r/g,'').trim())
                          .filter(line => line.length > 0);
    
    const { headerLineIndex, headerMonths } = getMonthHeaderIndices(lines);

    if (headerLineIndex === -1) {
        if (errorDiv) errorDiv.textContent = "ã‚¨ãƒ©ãƒ¼: ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œï¼ˆéƒ½é“åºœçœŒ, å¸‚å ´å, æœˆã‚’å«ã‚€è¡Œï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ­£ã—ã„å½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚";
        return;
    }
    
    window.allMonths = headerMonths;
    
    let currentMarketKey = null;
    let currentMetric = null;

    for (let i = headerLineIndex + 1; i < lines.length; i++) {
        const line = lines[i];

        if (line.includes("ãƒšãƒ¼ã‚¸ï¼š") || line.includes("ã€Š") || line.includes("å“ç¨®ï¼š") || line.includes("å–å¼•æœˆ") || line.includes("åˆè¨ˆãƒ»å¹³å‡")) continue;

        const isHeader = isMarketHeaderLine(line);

        if (isHeader) {
            const names = extractPrefAndMarket(line);
            const currentPrefName = names.prefecture;
            const currentMarketName = names.market;
            
            if (currentMarketName === 'çœŒåˆè¨ˆ') {
                currentMarketKey = null; 
                currentMetric = null;
                continue;
            }

            currentMarketKey = createMarketKey(currentPrefName, currentMarketName);
            if (!window.parsedData[currentMarketKey]) window.parsedData[currentMarketKey] = { 'é›„': {}, 'é›Œ': {}, 'è¨ˆ': {} };
            
            if (!window.allMarketKeysInOrder.includes(currentMarketKey)) {
                window.allMarketKeysInOrder.push(currentMarketKey);
            }

            currentMetric = null; 
            continue; 
        }

        if (!currentMarketKey) continue; 

        if (line.includes("å–å¼•é ­æ•°")) currentMetric = "count";
        else if (line.includes("å¹³å‡ä¾¡æ ¼")) currentMetric = "price";
        else if (line.includes("å¹³å‡ä½“é‡")) currentMetric = "weight";
        else if (line.includes("å¹³å‡æ—¥é½¢")) currentMetric = "age";
        else if (line.includes("ï¼‘ãå˜ä¾¡") || line.includes("1kgå˜ä¾¡")) currentMetric = "unitPrice";
        
        const isAverageLine = line.trim().startsWith('å¹³å‡');
        
        if (!currentMetric && !isAverageLine) continue;

        let parts = line.split(/\t/);
        if (parts.length <= 1) parts = line.split(/\s{2,}/);
        if (parts.length <= 1) parts = line.split(/,/);
        
        const hasFemale = line.includes("é›Œ");
        const hasMale = line.includes("é›„");
        
        const isCountTotalLine = currentMetric === 'count' && (line.includes("è¨ˆ") || line.includes("åˆè¨ˆ")) && !line.includes("å¹³å‡");
        const isMetricTotalOrAverageLine = (currentMetric !== 'count' && (line.includes("è¨ˆ") || line.includes("å¹³å‡"))) || isAverageLine;

        
        if (hasFemale) extractAllData(parts, headerMonths, currentMarketKey, 'é›Œ', currentMetric);
        if (hasMale) extractAllData(parts, headerMonths, currentMarketKey, 'é›„', currentMetric);
        
        if (isCountTotalLine || isMetricTotalOrAverageLine) {
            let targetMetric = currentMetric;
            
            if (isAverageLine && !currentMetric) { 
                for (let j = i - 1; j >= headerLineIndex; j--) {
                    if (lines[j].includes("å¹³å‡ä½“é‡")) { targetMetric = "weight"; break; }
                    if (lines[j].includes("å¹³å‡ä¾¡æ ¼")) { targetMetric = "price"; break; }
                    if (lines[j].includes("å¹³å‡æ—¥é½¢")) { targetMetric = "age"; break; }
                    if (lines[j].includes("å–å¼•é ­æ•°")) { targetMetric = "count"; break; }
                }
            }

            if (targetMetric) extractAllData(parts, headerMonths, currentMarketKey, 'è¨ˆ', targetMetric);
        }
    }

    if (Object.keys(window.parsedData).length === 0) {
        if (errorDiv) errorDiv.textContent = "æœ‰åŠ¹ãªå¸‚å ´ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
        return;
    }

    if (window.allMonths.length > 0) {
        if (window.parsedData['ç·åˆè¨ˆ']) {
            window.selectedMarkets.add('ç·åˆè¨ˆ');
        }
        window.allMarketKeysInOrder.forEach(key => {
            if (key.startsWith('åŒ—æµ·é“') || key.startsWith('å³¶æ ¹')) {
                 window.selectedMarkets.add(key);
            }
        });
        if (window.selectedMarkets.size === 0 && window.allMarketKeysInOrder.length > 0) {
            window.selectedMarkets.add(window.allMarketKeysInOrder[0]);
        }
    }

    renderAllAnalysisSections();
}

// --------------------------------------------------
// --- ui-renderer.js ã®å†…å®¹ (ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£) ---
// --------------------------------------------------

function formatValue(value) { 
    if (value === undefined || value === null || value === 0) return `-`;
    
    const selectedMetric = document.querySelector('input[name="metricSelector"]:checked').value;
    
    let formattedValue;

    if (selectedMetric === 'weight' || selectedMetric === 'age') {
        formattedValue = parseFloat(value).toFixed(1).toLocaleString();
    } else {
        formattedValue = Math.round(parseFloat(value)).toLocaleString();
    }
    
    return `<span class="score-value">${formattedValue}</span>`;
}

function renderTable(gender, containerId, analysisAreaId) {
    const container = document.getElementById(containerId);
    const analysisArea = document.getElementById(analysisAreaId);
    container.innerHTML = "";
    
    const selectedMetric = document.querySelector('input[name="metricSelector"]:checked').value;
    const metricInfo = METRICS[selectedMetric];

    const orderedMarketKeys = [];
    const totalKey = 'ç·åˆè¨ˆ';

    // ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹å¸‚å ´ã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
    // ã€é‡è¦ä¿®æ­£ã€‘ mInfo.index ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹
    window.allMarketKeysInOrder.forEach(k => {
        if (k !== totalKey && window.allMonths.some(mInfo => window.parsedData[k][gender] && window.parsedData[k][gender][mInfo.index] && window.parsedData[k][gender][mInfo.index][selectedMetric])) {
            orderedMarketKeys.push(k);
        }
    });

    if (window.parsedData[totalKey] && window.allMonths.some(mInfo => window.parsedData[totalKey][gender] && window.parsedData[totalKey][gender][mInfo.index] && window.parsedData[totalKey][gender][mInfo.index][selectedMetric])) {
        orderedMarketKeys.push(totalKey);
    }


    if (orderedMarketKeys.length === 0) {
        analysisArea.style.display = 'none'; 
        return; 
    }

    analysisArea.style.display = 'grid'; 

    let title = `ã€${gender}ã€‘ ${metricInfo.label} ã‚¯ãƒ­ã‚¹è¡¨`;
    
    let html = `<h2>${title}</h2>
    <table>
        <thead>
            <tr>
                <th class="checkbox-cell">â˜‘</th>
                <th class="pref-col">éƒ½é“åºœçœŒ</th>
                <th class="market-col">å¸‚å ´å</th>`;
    
    window.allMonths.forEach(mInfo => {
        html += `<th>${mInfo.month}æœˆ</th>`;
    });

    html += `</tr></thead><tbody>`;
    
    orderedMarketKeys.forEach(mKey => {
        const isTotal = mKey === 'ç·åˆè¨ˆ';
        const rowClass = isTotal ? 'class="total-row"' : '';
        
        let prefectureName = isTotal ? '---' : mKey.split('_')[0];
        let marketName = isTotal ? 'ç·åˆè¨ˆ' : mKey.split('_')[1];
        
        const checked = window.selectedMarkets.has(mKey) ? 'checked' : '';
        const checkbox = `<input type="checkbox" data-market-key="${mKey}" ${checked} onchange="handleMarketSelection(this)">`;
        
        html += `<tr ${rowClass}>
            <td class="checkbox-cell">${checkbox}</td>
            <td class="pref-col">${prefectureName}</td>
            <td class="market-col">${marketName}</td>`;
        
        // ã€é‡è¦ä¿®æ­£ã€‘ mInfo.index ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹
        window.allMonths.forEach(mInfo => {
            const value = window.parsedData[mKey][gender]?.[mInfo.index]?.[selectedMetric];
            html += `<td>${formatValue(value)}</td>`;
        });
        
        html += `</tr>`;
    });
    html += `</tbody></table>`;
    container.innerHTML = html;
}

// Chart.jsã‚’ä½¿ã£ãŸæŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ã®æç”»
function updateGraph(gender, canvasId, analysisAreaId) {
    const selectedMetric = document.querySelector('input[name="metricSelector"]:checked').value;
    const metricInfo = METRICS[selectedMetric];
    
    const labelElement = document.getElementById(canvasId).parentElement.querySelector('.graphMetricLabel');
    if (labelElement) {
        labelElement.textContent = metricInfo.label;
    }
    
    const datasets = [];
    
    const xAxisLabels = window.allMonths.map(mInfo => `${mInfo.month}æœˆ`);
    
    if (window.selectedMarkets.size > 0) {
        
        const marketKeysToDraw = Array.from(window.selectedMarkets).sort((a, b) => {
            if (a === 'ç·åˆè¨ˆ') return 1;
            if (b === 'ç·åˆè¨ˆ') return -1;
            return a.localeCompare(b, 'ja');
        });


        marketKeysToDraw.forEach(marketKey => {
            const marketName = marketKey === 'ç·åˆè¨ˆ' ? 'ç·åˆè¨ˆ' : marketKey.split('_')[1];
            const prefName = marketKey === 'ç·åˆè¨ˆ' ? '' : marketKey.split('_')[0];
            const isTotalKey = marketKey === 'ç·åˆè¨ˆ';
            
            const dataPoints = [];
            let hasData = false;
            
            // ã€é‡è¦ä¿®æ­£ã€‘ mInfo.index ã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹
            window.allMonths.forEach((mInfo, xIndex) => {
                const month = mInfo.month;
                const value = window.parsedData[marketKey]?.[gender]?.[mInfo.index]?.[selectedMetric];
                
                if (value !== undefined && value !== null) {
                    dataPoints.push({ x: xIndex, y: value, month: month });
                    hasData = true;
                } else {
                    dataPoints.push(null);
                }
            });

            if (hasData) {
                const styleKey = isTotalKey ? 'ç·åˆè¨ˆ' : gender;
                const style = GENDER_STYLES[styleKey];
                
                const borderWidth = isTotalKey ? 3 : 2; 

                datasets.push({
                    label: `${marketName}${isTotalKey ? '' : ` (${prefName})`}`,
                    data: dataPoints,
                    
                    backgroundColor: style.color,
                    borderColor: style.color, 
                    pointRadius: 5,
                    pointStyle: style.pointStyle, 
                    borderWidth: borderWidth, 
                    borderDash: style.dashPattern, 

                    showLine: true, 
                    tension: 0, 
                    fill: false,
                    type: 'line' 
                });
            }
        });
    }

    const ctx = document.getElementById(canvasId);
    if (!ctx) return; 

    const ctx_2d = ctx.getContext('2d');
    
    if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx_2d, {
        type: 'line', 
        data: {
            labels: xAxisLabels, 
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top', labels: { font: { size: 12 }, usePointStyle: true } },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const xIndex = context[0].dataIndex;
                            return xAxisLabels[xIndex]; 
                        },
                        label: function(context) {
                            const label = context.dataset.label || '';
                            let yValue = context.parsed.y;
                            
                            const metricLabel = `(${metricInfo.label})`;

                            if (selectedMetric === 'weight' || selectedMetric === 'age') {
                                yValue = parseFloat(yValue).toFixed(1).toLocaleString();
                            } else {
                                yValue = Math.round(yValue).toLocaleString();
                            }
                            return `${label} ${metricLabel}: ${yValue}${metricInfo.unit}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    type: 'category', 
                    title: { display: true, text: 'é–‹å‚¬æœˆ (Xè»¸)' },
                    grid: { drawOnChartArea: true } 
                },
                y: {
                    title: { display: true, text: metricInfo.axisLabel + ' (Yè»¸)' },
                    ticks: {
                        callback: function(value) { 
                            if (selectedMetric === 'weight' || selectedMetric === 'age') {
                                return value.toFixed(1) + metricInfo.unit;
                            } else {
                                return value.toLocaleString() + metricInfo.unit; 
                            }
                        }
                    }
                }
            }
        }
    });
}

function updateAllGraphs() {
    updateGraph('é›„', 'maleChart', 'maleAnalysisArea');
    updateGraph('é›Œ', 'femaleChart', 'femaleAnalysisArea');
    updateGraph('è¨ˆ', 'totalChart', 'totalAnalysisArea');
}

function renderAllAnalysisSections() {
    renderTable('é›„', 'maleTableSection', 'maleAnalysisArea');
    renderTable('é›Œ', 'femaleTableSection', 'femaleAnalysisArea');
    renderTable('è¨ˆ', 'totalTableSection', 'totalAnalysisArea');
    updateAllGraphs(); 
}


function handleMarketSelection(checkbox) {
    const marketKey = checkbox.getAttribute('data-market-key');
    if (checkbox.checked) {
        window.selectedMarkets.add(marketKey);
    } else {
        window.selectedMarkets.delete(marketKey);
    }
    renderAllAnalysisSections(); 
}

function handleMetricChange() {
    renderAllAnalysisSections();
}


// --- åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ ---
window.onload = function() {
    const dataInput = document.getElementById('dataInput');
    const metricSelectors = document.querySelectorAll('input[name="metricSelector"]');

    dataInput.addEventListener('input', processData);
    metricSelectors.forEach(radio => {
        radio.addEventListener('change', handleMetricChange);
    });
    
    window.handleMarketSelection = handleMarketSelection;

    const defaultRadio = document.querySelector('input[name="metricSelector"][value="count"]');
    if (defaultRadio) {
        defaultRadio.checked = true;
    }
    
    processData();
};
</script>

</body>
</html>