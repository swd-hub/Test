<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Professional Data Processor (Latest Record First)</title>
    <style>
        :root {
            --primary: #4f46e5;
            --bg: #f1f5f9;
            --card: #ffffff;
            --border: #e2e8f0;
            --text-main: #1e293b;
            --accent: #f59e0b;
        }
        body { font-family: sans-serif; background-color: var(--bg); color: var(--text-main); padding: 20px; }
        .container { max-width: 1200px; margin: auto; }
        .card { background: var(--card); padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); margin-bottom: 20px; }
        h3 { border-left: 5px solid var(--primary); padding-left: 15px; font-size: 1rem; margin-top: 0; }
        textarea { width: 100%; height: 120px; border: 2px dashed var(--border); border-radius: 8px; padding: 10px; cursor: pointer; box-sizing: border-box; }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .stat-item { background: #f8fafc; border: 1px solid var(--border); padding: 10px; border-radius: 8px; text-align: center; }
        .stat-value { display: block; font-size: 1.2rem; font-weight: bold; color: var(--primary); }
        .stat-label { font-size: 0.75rem; color: #64748b; }

        .config-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px; }
        .header-item-card { background: #f8fafc; border: 1px solid var(--border); padding: 12px; border-radius: 8px; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 20px; background: white; table-layout: fixed; }
        th, td { border: 1px solid var(--border); padding: 10px; text-align: center; word-wrap: break-word; }
        th { background: #f8fafc; }
        .preview-title { text-align: center; font-size: 1.5rem; margin: 20px 0; font-weight: bold; }
        .btn-group { margin-bottom: 15px; }
        .btn { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; margin-right: 5px; }
        .btn-success { background: #10b981; color: white; }
        .btn-warning { background: var(--accent); color: white; }
        .btn-primary { background: var(--primary); color: white; }

        @media print {
            .no-print, .btn-group { display: none !important; }
            body, .container, .card { background: white !important; padding: 0 !important; margin: 0 !important; box-shadow: none !important; width: 100% !important; }
            @page { size: A4 landscape; margin: 15mm; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="card no-print">
        <h3>基本設定</h3>
        <input type="text" id="tableTitle" placeholder="表題を入力" style="width: 100%; padding: 10px; box-sizing: border-box;" oninput="renderTable()">
    </div>

    <div class="card no-print">
        <h3>CSVデータ読み込み</h3>
        <textarea id="csvInput" ondblclick="document.getElementById('fileHidden').click()" oninput="processData()" placeholder="CSVを貼り付け（ダブルクリックでファイル選択）"></textarea>
        <input type="file" id="fileHidden" style="display:none" accept=".csv" onchange="handleFile(event)">
        
        <div id="statsPanel" style="margin-top:15px; display:none;">
            <div class="stats-grid">
                <div class="stat-item"><span class="stat-label">入力総行数</span><span id="statTotal" class="stat-value">0</span></div>
                <div class="stat-item"><span class="stat-label">完全重複(全一致)</span><span id="statFullDup" class="stat-value">0</span></div>
                <div class="stat-item"><span class="stat-label">日付違いで重複</span><span id="statDateDup" class="stat-value">0</span></div>
                <div class="stat-item"><span class="stat-label">有効(ユニーク)データ</span><span id="statUnique" class="stat-value">0</span></div>
                <div class="stat-item" style="border-color: var(--accent);">
                    <span class="stat-label">表のサイズ(ヘッダー込)</span>
                    <span id="statTableDim" class="stat-value">0行 × 0列</span>
                </div>
            </div>
            表示フィルタ（基準日以降）: <input type="date" id="dateFilter" onchange="processData()">
        </div>
    </div>

    <div id="configSection" class="card no-print" style="display:none;">
        <h3>クロス表のカラム設定</h3>
        <div id="headerSettings" class="config-grid"></div>
    </div>

    <div class="card">
        <div class="btn-group no-print">
            <button class="btn btn-success" onclick="exportCSV()">CSV保存</button>
            <button class="btn btn-warning" onclick="exportJSON()">JSON保存</button>
            <button class="btn btn-primary" onclick="window.print()">PDF出力</button>
        </div>
        <div id="displayTitle" class="preview-title"></div>
        <div id="tablePreview"></div>
    </div>
</div>

<script>
let processedDataList = [];
let nameGroupedData = {}; 
let headerConfigs = [];
let stats = { total: 0, fullDup: 0, dateDup: 0, unique: 0 };
let currentTableStats = { rows: 0, cols: 0 };

function handleFile(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        document.getElementById('csvInput').value = event.target.result;
        processData();
    };
    reader.readAsText(file);
}

function processData() {
    const text = document.getElementById('csvInput').value.trim();
    if (!text) return;
    
    const lines = text.split('\n').filter(l => l.trim() !== "");
    stats.total = lines.length;

    // 1. 完全一致の排除
    const uniqueLines = [...new Set(lines)];
    stats.fullDup = stats.total - uniqueLines.length;

    // 2. 名前・項目・内容が一致する場合に「最新」を優先
    const latestMap = new Map();
    const itemSet = new Set();
    let dateDupCount = 0;

    uniqueLines.forEach(line => {
        const cols = line.split(/,|\t/).map(s => s.trim().replace(/^"|"$/g, ''));
        if (cols.length < 4) return;
        let [dateStr, name, item, content] = cols;
        const dateObj = new Date(dateStr.replace(/-/g, '/'));
        const key = `${name}|${item}|${content}`;
        
        if (!latestMap.has(key)) {
            latestMap.set(key, { date: dateStr, name, item, content, timestamp: dateObj.getTime() });
        } else {
            dateDupCount++; 
            // 既存より「新しい」日付なら上書き
            if (dateObj.getTime() > latestMap.get(key).timestamp) {
                latestMap.set(key, { date: dateStr, name, item, content, timestamp: dateObj.getTime() });
            }
        }
        itemSet.add(item);
    });

    stats.dateDup = dateDupCount;
    processedDataList = Array.from(latestMap.values());
    stats.unique = processedDataList.length;

    const filterDate = document.getElementById('dateFilter').value;
    const filterTimestamp = filterDate ? new Date(filterDate).getTime() : 0;

    nameGroupedData = {};
    processedDataList.forEach(d => {
        if (d.timestamp >= filterTimestamp) {
            if (!nameGroupedData[d.name]) nameGroupedData[d.name] = [];
            nameGroupedData[d.name].push(d);
        }
    });

    const newItems = Array.from(itemSet);
    if (headerConfigs.length === 0) {
        headerConfigs = newItems.map((item, i) => ({
            raw: item, alias: item, order: i + 1, mode: 'content'
        }));
    }

    document.getElementById('statsPanel').style.display = 'block';
    document.getElementById('configSection').style.display = 'block';
    renderHeaderConfigUI();
    renderTable();
}

function renderHeaderConfigUI() {
    const container = document.getElementById('headerSettings');
    container.innerHTML = headerConfigs.map((config, i) => `
        <div class="header-item-card">
            <div class="input-row">
                <input type="number" value="${config.order}" min="0" onchange="updateOrder(${i}, this.value)">
                <input type="text" value="${config.alias}" oninput="headerConfigs[${i}].alias=this.value; renderTable()">
            </div>
            <div style="font-size:0.8rem;">
                <label><input type="radio" name="m_${i}" value="content" ${config.mode==='content'?'checked':''} onchange="headerConfigs[${i}].mode='content'; renderTable()">内容</label>
                <label><input type="radio" name="m_${i}" value="date" ${config.mode==='date'?'checked':''} onchange="headerConfigs[${i}].mode='date'; renderTable()">日付</label>
            </div>
        </div>
    `).join('');
}

function updateOrder(index, newOrder) {
    newOrder = parseInt(newOrder);
    if (newOrder > 0) {
        headerConfigs.forEach((config, i) => {
            if (i === index) return;
            if (config.order >= newOrder && config.order !== 0) config.order += 1;
        });
    }
    headerConfigs[index].order = newOrder;
    renderHeaderConfigUI();
    renderTable();
}

function renderTable() {
    document.getElementById('displayTitle').innerText = document.getElementById('tableTitle').value;
    const activeConfigs = headerConfigs.filter(c => c.order > 0).sort((a, b) => a.order - b.order);
    const names = Object.keys(nameGroupedData);

    currentTableStats.rows = names.length + 1;
    currentTableStats.cols = activeConfigs.length + 1; 

    let html = `<table><thead><tr><th>氏名</th>`;
    activeConfigs.forEach(c => html += `<th>${c.alias}</th>`);
    html += `</tr></thead><tbody>`;

    names.forEach(name => {
        html += `<tr><td><strong>${name}</strong></td>`;
        activeConfigs.forEach(c => {
            // ここで「鈴木×打合せ」に対して該当するデータ(233件の中にあるもの)を表示
            // ※複数ある場合は最初の1つが表示される
            const entry = nameGroupedData[name].find(d => d.item === c.raw);
            html += `<td>${entry ? (c.mode === 'content' ? entry.content : entry.date) : '-'}</td>`;
        });
        html += `</tr>`;
    });
    html += `</tbody></table>`;
    
    document.getElementById('tablePreview').innerHTML = html;
    
    document.getElementById('statTotal').innerText = stats.total;
    document.getElementById('statFullDup').innerText = stats.fullDup;
    document.getElementById('statDateDup').innerText = stats.dateDup;
    document.getElementById('statUnique').innerText = stats.unique;
    document.getElementById('statTableDim').innerText = `${currentTableStats.rows}行 × ${currentTableStats.cols}列`;
}

function getTimestampStr() {
    const now = new Date();
    return now.getFullYear() +
        String(now.getMonth() + 1).padStart(2, '0') +
        String(now.getDate()).padStart(2, '0') +
        String(now.getHours()).padStart(2, '0') +
        String(now.getMinutes()).padStart(2, '0');
}

function exportCSV() {
    const table = document.querySelector("table");
    if(!table) return;
    let csv = [];
    for (let i = 0; i < table.rows.length; i++) {
        let row = [], cols = table.rows[i].cells;
        for (let j = 0; j < cols.length; j++) row.push('"' + cols[j].innerText + '"');
        csv.push(row.join(","));
    }
    const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csv.join("\n")], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `table_${getTimestampStr()}.csv`;
    link.click();
}

function exportJSON() {
    const userFocusData = [];
    for (const name in nameGroupedData) {
        userFocusData.push({
            name: name,
            records: nameGroupedData[name].map(r => ({
                date: r.date,
                item: r.item,
                content: r.content
            }))
        });
    }

    const output = {
        meta: {
            filename: `data_${getTimestampStr()}.json`,
            note: "Kept latest date for Name+Item+Content matches.",
            stats: {
                input_total_lines: stats.total,
                full_duplicate_removed: stats.fullDup,
                different_date_duplicate_removed: stats.dateDup,
                final_unique_data_count: stats.unique,
                preview_table_rows_incl_header: currentTableStats.rows,
                preview_table_cols: currentTableStats.cols
            }
        },
        payload: userFocusData
    };

    const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = output.meta.filename;
    link.click();
}
</script>
</body>
</html>