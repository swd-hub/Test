<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆå…¨é …ç›®ï¼šå®Ÿæ•°è¡¨ç¤ºï¼‰</title>
    
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; padding: 20px; background-color: #f4f6f9; color: #333; }
        h1 { font-size: 1.4rem; margin-bottom: 10px; border-bottom: 2px solid #ddd; padding-bottom: 10px; }

        .container { 
            max-width: 1800px; 
            margin: 0 auto; 
            background: #fff; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
        }

        .header-top { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        .header-top h1 { margin: 0; flex: 1; min-width: 300px; } 

        #sourceButton {
            padding: 10px 20px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
        }
        #sourceButton:hover { background-color: #5a6268; }

        .input-area { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
        textarea { width: 100%; height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px; }

        .controls { margin-top: 15px; display: flex; gap: 15px; align-items: center; background: #eef; padding: 15px; border-radius: 5px; flex-wrap: wrap; }
        input[type="text"], input[type="number"] { padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
        input[type="number"] { width: 80px; }

        #errorMessage { color: red; font-weight: bold; margin-top: 10px; }

        .tables-container { 
            display: flex; 
            flex-direction: column; 
            gap: 30px; 
            overflow-x: auto; 
        }
        .gender-section h2 { background-color: #343a40; color: white; padding: 10px; margin: 0; font-size: 1.1rem; border-radius: 4px 4px 0 0; }

        table { 
            width: 100%; 
            min-width: 1000px; 
            border-collapse: collapse; 
            font-size: 13px; 
            background: white; 
        }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { 
            background-color: #f8f9fa; 
            color: #333; 
            font-weight: bold; 
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover { background-color: #e2e6ea; }
        th.sort-asc::after { content: " â–²"; color: #007bff; }
        th.sort-desc::after { content: " â–¼"; color: #007bff; }

        tr:nth-child(even) { background-color: #fcfcfc; }
        tr:hover { background-color: #f1f1f1; }

        .market-name-col { text-align: left; font-weight: bold; }
        .total-row { background-color: #e9ecef; font-weight: bold; }
        .total-row td { background-color: #e9ecef; }

        .score-value { font-weight: bold; font-size: 1.1em; }
        /* å®Ÿæ•°è¡¨ç¤ºç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .real-value { font-weight: bold; color: #000; } 

        .score-note { font-size: 0.9rem; color: #666; margin-bottom: 10px; }

        .date-controls {
            display: flex;
            align-items: center;
            gap: 15px; 
            flex-wrap: wrap;
        }
    </style>
    
</head>
<body>

<div class="container">
    <div class="header-top">
        <h1>ğŸ“Š å¸‚å ´ãƒ‡ãƒ¼ã‚¿åˆ†æãƒ„ãƒ¼ãƒ«ï¼ˆå…¨é …ç›®ï¼šå®Ÿæ•°è¡¨ç¤ºï¼‰</h1>
        <a id="sourceButton" href="https://www.alic.go.jp/operation/livestock/calf-report.html" target="_blank">è‚‰ç”¨å­ç‰›å–å¼•æƒ…å ±ã‚µã‚¤ãƒˆã¸</a>
    </div>
    
    <p class="score-note">
        â€» **çœŒåˆè¨ˆã®ãƒ‡ãƒ¼ã‚¿**ã¯é™¤å¤–ã—ã¦ã‚ã‚Šã¾ã™ã€‚<br>
        â€» **ã™ã¹ã¦ã®åˆ—**ã§**å…ƒã®ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿæ•°ï¼‰**ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚
    </p>
    <div class="input-area">
        <textarea id="dataInput" placeholder="ã“ã“ã«Excelã‹ã‚‰ã‚³ãƒ”ãƒ¼ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„..."></textarea>
        <div class="controls">
            <div class="date-controls">
                <label>æŠ½å‡ºå¯¾è±¡æœˆ: <input type="number" id="targetMonth" placeholder="ä¾‹: 8"></label>
                <span id="transactionDateDisplay">å–å¼•æœˆ ä»¤å’Œ å¹´ æœˆ æ—¥ï½ä»¤å’Œ å¹´ æœˆ æ—¥</span>
            </div>
        </div>
        <div id="errorMessage"></div>
    </div>
    
    <pre id="pdDebugArea" style="background: #fffef0; border: 1px solid #f0c36d; padding: 8px; font-size: 12px; overflow: auto; margin-bottom: 20px; display: none;"></pre>

    <div id="resultArea" class="tables-container"></div>
</div>

<script>
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨å®šæ•° ---
window.parsedDataByGender = { 'é›„': [], 'é›Œ': [], 'è¨ˆ': [] };
window.marketMap = {};
window.sortState = {
    'é›„': { key: null, dir: 'desc' }, 
    'é›Œ': { key: null, dir: 'desc' },
    'è¨ˆ': { key: null, dir: 'desc' }
};

window.metricsMap = [
    { key: 'count', label: 'å–å¼•é ­æ•°', unit: 'é ­', isPrice: false },
    { key: 'price', label: 'å¹³å‡ä¾¡æ ¼', unit: 'å††', isPrice: true },
    { key: 'weight', label: 'å¹³å‡ä½“é‡', unit: 'kg', isPrice: false },
    { key: 'age', label: 'å¹³å‡æ—¥é½¢', unit: 'æ—¥', isPrice: false },
    { key: 'unitPrice', label: '1kgå˜ä¾¡', unit: 'å††', isPrice: true }
];

// --------------------------------------------------
// --- data-parser.js ã®å†…å®¹ (è§£æãƒ»å®Ÿæ•°æ ¼ç´ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£) ---
// --------------------------------------------------

function extractPrefAndMarket(line) {
    const parts = line.split(/[\t,]/).map(p => p.trim());
    let prefecture = '';
    let market = '';
    if (parts[0]) {
        prefecture = parts[0];
    }
    if (parts.length > 1 && parts[1]) {
        market = parts[1].replace(/\*|-/g, '').trim();
    }
    if (line.includes('ç·åˆè¨ˆ')) {
        prefecture = 'ç·åˆè¨ˆ';
        market = '';
    }
    return { prefecture, market };
}
function createMarketKey(prefecture, market) {
    if (prefecture === 'ç·åˆè¨ˆ') return 'ç·åˆè¨ˆ';
    return `${prefecture}_${market}`;
}
function isMarketHeaderLine(line) {
    if (line.includes("ãƒšãƒ¼ã‚¸") || line.includes("æœˆåˆ¥è‚‰ç”¨å­ç‰›å–å¼•çŠ¶æ³è¡¨") || line.includes("éƒ½é“åºœçœŒ") || line.includes("å“ç¨®ï¼š") || line.includes("åˆè¨ˆãƒ»å¹³å‡")) return false;
    const prefs = ["åŒ—æµ·é“", "é’æ£®", "å²©æ‰‹", "å®®åŸ", "ç§‹ç”°", "å±±å½¢", "ç¦å³¶", "èŒ¨åŸ", "æ ƒæœ¨", "ç¾¤é¦¬", "åŸ¼ç‰", "åƒè‘‰", "æ±äº¬", "ç¥å¥ˆå·", "æ–°æ½Ÿ", "å¯Œå±±", "çŸ³å·", "ç¦äº•", "å±±æ¢¨", "é•·é‡", "å²é˜œ", "é™å²¡", "æ„›çŸ¥", "ä¸‰é‡", "æ»‹è³€", "äº¬éƒ½", "å¤§é˜ª", "å…µåº«", "å¥ˆè‰¯", "å’Œæ­Œå±±", "é³¥å–", "å³¶æ ¹", "å²¡å±±", "åºƒå³¶", "å±±å£", "å¾³å³¶", "é¦™å·", "æ„›åª›", "é«˜çŸ¥", "ç¦å²¡", "ä½è³€", "é•·å´", "ç†Šæœ¬", "å¤§åˆ†", "å®®å´", "é¹¿å…å³¶", "æ²–ç¸„"];
    
    let parts = line.split(/\t/).map(p => p.trim());
    parts = parts.filter(p => p.length > 0); 

    if (parts.length < 2 && line.includes(',')) {
        parts = line.split(/,/).map(p => p.trim());
        parts = parts.slice(0, 2).filter(p => p.length > 0);
    }
    
    if (line.includes("ç·åˆè¨ˆ") && !line.includes("åˆè¨ˆãƒ»å¹³å‡")) return true;
    
    const isPrefecture = prefs.some(p => parts[0] && parts[0].includes(p));
    const isMarket = parts[1] && (parts[1].includes('å¸‚å ´') || parts[1].includes('å®¶ç•œ'));

    if (line.includes("è¨ˆ") && !line.includes("å–å¼•é ­æ•°") && !line.includes("åˆè¨ˆãƒ»å¹³å‡")) return false; 
    
    return isPrefecture && isMarket;
}

function extractAndStore(parts, dataStartIndexInLine, currentMarketKey, gender, metricKey) {
    if (!metricKey || !currentMarketKey) return;

    const correctDataIndex = dataStartIndexInLine - 1; 
    let value = null;

    if (correctDataIndex >= 0 && correctDataIndex < parts.length) {
        value = parts[correctDataIndex];
    }
    
    if (!value || value.trim() === '') {
        value = parts[dataStartIndexInLine];
    }
    
    if (value && value.trim() !== '') {
        const val = parseFloat(value.replace(/,/g, '').trim());
        if (!isNaN(val)) {
            if (!window.marketMap[currentMarketKey][gender]) {
                 window.marketMap[currentMarketKey][gender] = {};
            }
            window.marketMap[currentMarketKey][gender][metricKey] = val;
        }
    }
}


// --- ã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---
function calculateScores() {
    // ã‚¹ã‚³ã‚¢ã¨ã—ã¦å…ƒã®å®Ÿæ•°å€¤ã‚’ãã®ã¾ã¾ä½¿ç”¨
    ['é›„', 'é›Œ', 'è¨ˆ'].forEach(gender => {
        let data = window.parsedDataByGender[gender];
        if (!data || data.length === 0) return;

        const metrics = window.metricsMap; 

        metrics.forEach(m => {
            const metricKey = m.key;
            
            data.forEach(row => {
                const realVal = row[metricKey]; 
                row[`${metricKey}Score`] = null; 
                
                if (realVal !== null && realVal !== 0) {
                    row[`${metricKey}Score`] = realVal; 
                }
            });
        });
        
        window.parsedDataByGender[gender] = data;
    });
}


// --------------------------------------------------
// --- ui-renderer.js ã®å†…å®¹ (ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ»ã‚½ãƒ¼ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£) ---
// --------------------------------------------------

function formatScoreValue(score, key) { 
    if (score === undefined || score === null || score === '-') return `-`;
    
    const metric = window.metricsMap.find(m => m.key === key);
    if (!metric) return score;

    const num = Math.round(parseFloat(score));
    if (isNaN(num)) return score;
    
    return `<span class="score-value real-value">${num.toLocaleString()}</span>`;
}

function sortTable(gender, key) { 
    const data = window.parsedDataByGender[gender].filter(row => row.key !== 'ç·åˆè¨ˆ');
    const totalRow = window.parsedDataByGender[gender].find(row => row.key === 'ç·åˆè¨ˆ');

    if (window.sortState[gender].key === key) {
        window.sortState[gender].dir = window.sortState[gender].dir === 'asc' ? 'desc' : 'asc';
    } else {
        window.sortState[gender].key = key;
        
        if (key === 'prefecture' || key === 'market') {
            window.sortState[gender].dir = 'asc'; 
        } else {
            const metric = window.metricsMap.find(m => m.key === key);
            // ä¾¡æ ¼ã¯é™é †ã€ãã®ä»–ã‚‚é™é †ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            window.sortState[gender].dir = 'desc'; 
        }
    }
    const dir = window.sortState[gender].dir;

    data.sort((a, b) => {
        if (key === 'prefecture' || key === 'market') {
            const comp = a[key].localeCompare(b[key], 'ja');
            return dir === 'asc' ? comp : -comp;
        }
        
        const sortKey = `${key}Score`; 
        const valA = a[sortKey];
        const valB = b[sortKey];

        const isInvalidA = (valA === null || valA === undefined || valA === '-');
        const isInvalidB = (valB === null || valB === undefined || valB === '-');

        if (isInvalidA && isInvalidB) return 0;
        if (isInvalidA) return 1; 
        if (isInvalidB) return -1; 

        if (dir === 'asc') {
           return valA - valB;
        } else {
           return valB - valA;
        }
    });

    window.parsedDataByGender[gender] = totalRow ? [...data, totalRow] : data;
    renderTables();
}
window.sortTable = sortTable; 

function renderTables() {
    const container = document.getElementById('resultArea');
    container.innerHTML = "";
    
    ['é›„', 'é›Œ', 'è¨ˆ'].forEach(g => {
        const data = window.parsedDataByGender[g];
        if (data.length === 0) return;

        const section = document.createElement('div');
        section.className = 'gender-section';
        
        let title = `ã€${g}ã€‘ å¸‚å ´ãƒ‡ãƒ¼ã‚¿ä¸€è¦§ï¼ˆå…¨é …ç›® å®Ÿæ•°ï¼‰`;
        
        let html = `<h2>${title}</h2>
        <table>
            <thead>
                <tr>
                    <th onclick="sortTable('${g}', 'prefecture')" class="${window.sortState[g].key === 'prefecture' ? 'sort-' + window.sortState[g].dir : ''}">éƒ½é“åºœçœŒ</th>
                    <th onclick="sortTable('${g}', 'market')" class="${window.sortState[g].key === 'market' ? 'sort-' + window.sortState[g].dir : ''}">å¸‚å ´å</th>`;
        
        window.metricsMap.forEach(m => {
            let headerLabel = `${m.label}<br>ï¼ˆå®Ÿæ•°ï¼š${m.unit}ï¼‰`;

            const isSorted = window.sortState[g].key === m.key;
            const sortClass = isSorted ? 'sort-' + (window.sortState[g].key === m.key ? window.sortState[g].dir : '') : '';
            
            html += `<th onclick="sortTable('${g}', '${m.key}')" class="${sortClass}">${headerLabel}</th>`;
        });
        html += `</tr></thead><tbody>`;
        
        data.forEach(row => {
            const isTotal = row.key === 'ç·åˆè¨ˆ';
            const rowClass = isTotal ? 'class="total-row"' : '';
            
            const prefDisplay = isTotal ? `<td class="market-name-col" colspan="2">ç·åˆè¨ˆ</td>` : 
                                          `<td class="market-name-col">${row.prefecture}</td><td class="market-name-col">${row.market}</td>`;
            
            html += `<tr ${rowClass}>${prefDisplay}`;
            
            window.metricsMap.forEach(m => {
                const displayValue = formatScoreValue(row[`${m.key}Score`], m.key);
                html += `<td>${displayValue}</td>`;
            });
            html += `</tr>`;
        });
        html += `</tbody></table>`;
        section.innerHTML = html;
        container.appendChild(section);
    });
}


function updateTransactionDateDisplay_main(text) {
    const displayElement = document.getElementById('transactionDateDisplay');
    const regex = /å–å¼•æœˆ\s*(\S+)/; 
    const match = text.match(regex);
    if (match && match[1]) {
        const dateRange = match[1].replace(/\s/g, ''); 
        const dateRegex = /(ä»¤å’Œ)(\d{1,2})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥ï½(ä»¤å’Œ)(\d{1,2})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥/;
        const dateMatch = dateRange.match(dateRegex);
        if (dateMatch) {
            const startYear = parseInt(dateMatch[2], 10);
            const startMonth = parseInt(dateMatch[3], 10);
            const startDay = parseInt(dateMatch[4], 10);
            const endYear = parseInt(dateMatch[6], 10);
            const endMonth = parseInt(dateMatch[7], 10);
            const endDay = parseInt(dateMatch[8], 10);
            displayElement.textContent = `å–å¼•æœˆ ä»¤å’Œ${startYear}å¹´${startMonth}æœˆ${startDay}æ—¥ï½ä»¤å’Œ${endYear}å¹´${endMonth}æœˆ${endDay}æ—¥`;
        } else {
            displayElement.textContent = `å–å¼•æœˆ ${dateRange}`;
        }
    } else {
        displayElement.textContent = 'å–å¼•æœˆ æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚';
    }
}


// --------------------------------------------------
// --- main.js ã®å†…å®¹ (ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ»åˆæœŸåŒ–) ---
// --------------------------------------------------

function getMonthHeaderIndices(lines) {
    let headerLineIndex = -1;

    for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('éƒ½é“åºœçœŒ') && lines[i].includes('å¸‚å ´å') && lines[i].includes('æœˆ')) {
            headerLineIndex = i;
            break;
        }
    }
    
    if (headerLineIndex === -1) return { headerLineIndex: -1, headerMonths: [] };

    let fullHeaderParts = lines[headerLineIndex].split(/\t/);
    if (fullHeaderParts.length <= 1) fullHeaderParts = lines[headerLineIndex].split(/\s{2,}/);
    if (fullHeaderParts.length <= 1) fullHeaderParts = lines[headerLineIndex].split(/,/);

    const headerMonths = [];

    for (let i = 0; i < fullHeaderParts.length; i++) {
        let part = fullHeaderParts[i]; 
        if (!part) continue; 

        let trimmedPart = part.trim();
        
        if (trimmedPart.includes('åˆè¨ˆ') || trimmedPart.includes('å¹³å‡')) continue;

        trimmedPart = trimmedPart.replace(/ï¼ˆ.*?ï¼‰/g,'').replace(/\s+/g,'');
        const digits = trimmedPart.replace(/[^0-9ï¼-ï¼™]/g, '');
        const half = digits.replace(/[ï¼-ï¼™]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
        const m = parseInt(half,10);

        if (!isNaN(m) && m >= 1 && m <= 12 && (trimmedPart.endsWith('æœˆ') || trimmedPart === String(m))) {
            headerMonths.push({ month: m, index: i, text: fullHeaderParts[i] });
        }
    }
    
    return { headerLineIndex, headerMonths };
}

function processData() {
    const rawInput = document.getElementById('dataInput').value;
    const targetMonthElement = document.getElementById('targetMonth');
    const targetMonth = targetMonthElement.value.trim();
    const errorDiv = document.getElementById('errorMessages') || document.getElementById('errorMessage'); 
    const resultDiv = document.getElementById('tablesContainer') || document.getElementById('resultArea'); 
    const dbg = document.getElementById('pdDebugArea');

    if (dbg) dbg.textContent = '';
    if (errorDiv) errorDiv.textContent = "";
    if (resultDiv) resultDiv.innerHTML = "";
    
    window.parsedDataByGender = { 'é›„': [], 'é›Œ': [], 'è¨ˆ': [] };
    window.marketMap = {};
    
    const monthNum = parseInt(targetMonth, 10);
    if (!rawInput.trim() || isNaN(monthNum) || monthNum < 1 || monthNum > 12) {
        if (errorDiv) errorDiv.textContent = "ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã€æŠ½å‡ºå¯¾è±¡æœˆï¼ˆ1ï½12ã®æ•°å€¤ï¼‰ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„ã€‚";
        // ãƒ‡ãƒ¼ã‚¿ãŒè²¼ã‚Šä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„å ´åˆã€å‡¦ç†ã‚’ä¸­æ–­
        if (!rawInput.trim()) return; 
    }

    const lines = rawInput.split('\n')
                          .map(line => line.replace(/\r/g,'').trim())
                          .filter(line => line.length > 0);
    
    if (typeof updateTransactionDateDisplay_main === 'function') {
        updateTransactionDateDisplay_main(rawInput); 
    }
    
    const { headerLineIndex, headerMonths } = getMonthHeaderIndices(lines);

    if (headerLineIndex === -1) {
        if (errorDiv) errorDiv.textContent = "ã‚¨ãƒ©ãƒ¼: ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œï¼ˆéƒ½é“åºœçœŒ, å¸‚å ´å, æœˆã‚’å«ã‚€è¡Œï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ­£ã—ã„å½¢å¼ã§ãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚";
        return;
    }

    const matches = headerMonths.filter(h => h.month === monthNum);

    if (matches.length === 0) {
        if (errorDiv) errorDiv.textContent = `ã‚¨ãƒ©ãƒ¼: æŒ‡å®šã•ã‚ŒãŸæœˆï¼ˆ${monthNum}æœˆï¼‰ã®ãƒ‡ãƒ¼ã‚¿åˆ—ãŒãƒ˜ãƒƒãƒ€ãƒ¼ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`;
        return;
    }

    const dataStartIndexInLine = matches[matches.length - 1].index;
    
    let currentMarketKey = null;
    let currentMetric = null;

    for (let i = headerLineIndex + 1; i < lines.length; i++) {
        const line = lines[i];

        if (line.includes("ãƒšãƒ¼ã‚¸ï¼š") || line.includes("ã€Š") || line.includes("å“ç¨®ï¼š") || line.includes("å–å¼•æœˆ") || line.includes("åˆè¨ˆãƒ»å¹³å‡")) continue;

        const isHeader = typeof isMarketHeaderLine === 'function' ? isMarketHeaderLine(line) : false;

        if (isHeader) {
            const names = typeof extractPrefAndMarket === 'function' ? extractPrefAndMarket(line) : {};
            const currentPrefName = names.prefecture;
            const currentMarketName = names.market;
            
            if (currentMarketName === 'çœŒåˆè¨ˆ' || currentPrefName === 'ç·åˆè¨ˆ') {
                currentMarketKey = currentPrefName === 'ç·åˆè¨ˆ' ? 'ç·åˆè¨ˆ' : null; 
                if (currentMarketKey === 'ç·åˆè¨ˆ' && !window.marketMap[currentMarketKey]) {
                    window.marketMap[currentMarketKey] = { 'é›„': {}, 'é›Œ': {}, 'è¨ˆ': {} };
                }
                currentMetric = null;
                continue;
            }

            currentMarketKey = typeof createMarketKey === 'function' ? createMarketKey(currentPrefName, currentMarketName) : `${currentPrefName}_${currentMarketName}`;
            
            if (!window.marketMap[currentMarketKey]) window.marketMap[currentMarketKey] = { 'é›„': {}, 'é›Œ': {}, 'è¨ˆ': {} };
            currentMetric = null; 
            continue; 
        }

        if (!currentMarketKey) continue; 

        if (line.includes("å–å¼•é ­æ•°")) currentMetric = "count";
        else if (line.includes("å¹³å‡ä¾¡æ ¼")) currentMetric = "price";
        else if (line.includes("å¹³å‡ä½“é‡")) currentMetric = "weight";
        else if (line.includes("å¹³å‡æ—¥é½¢")) currentMetric = "age";
        else if (line.includes("ï¼‘ãå˜ä¾¡") || line.includes("1kgå˜ä¾¡")) currentMetric = "unitPrice";
        
        const isAverageLine = line.trim().startsWith('å¹³å‡');
        
        if (!currentMetric && !isAverageLine) continue;

        let parts = line.split(/\t/);
        if (parts.length <= 1) parts = line.split(/\s{2,}/);
        if (parts.length <= 1) parts = line.split(/,/);
        
        const hasFemale = line.includes("é›Œ");
        const hasMale = line.includes("é›„");
        
        const isCountTotalLine = currentMetric === 'count' && (line.includes("è¨ˆ") || line.includes("åˆè¨ˆ")) && !line.includes("å¹³å‡");
        const isMetricTotalOrAverageLine = (currentMetric !== 'count' && (line.includes("è¨ˆ") || line.includes("å¹³å‡"))) || isAverageLine;

        
        if (typeof extractAndStore === 'function') {
            if (hasFemale) extractAndStore(parts, dataStartIndexInLine, currentMarketKey, 'é›Œ', currentMetric);
            if (hasMale) extractAndStore(parts, dataStartIndexInLine, currentMarketKey, 'é›„', currentMetric);
            
            if (isCountTotalLine || isMetricTotalOrAverageLine) {
                let targetMetric = currentMetric;
                
                if (isAverageLine && !currentMetric) { 
                    for (let j = i - 1; j >= headerLineIndex; j--) {
                        if (lines[j].includes("å¹³å‡ä½“é‡")) { targetMetric = "weight"; break; }
                        if (lines[j].includes("å¹³å‡ä¾¡æ ¼")) { targetMetric = "price"; break; }
                        if (lines[j].includes("å¹³å‡æ—¥é½¢")) { targetMetric = "age"; break; }
                        if (lines[j].includes("å–å¼•é ­æ•°")) { targetMetric = "count"; break; }
                    }
                }

                if (targetMetric) extractAndStore(parts, dataStartIndexInLine, currentMarketKey, 'è¨ˆ', targetMetric);
            }
        }
    }

    Object.keys(window.marketMap).forEach(mKey => {
        ['é›„', 'é›Œ', 'è¨ˆ'].forEach(g => {
            if (Object.keys(window.marketMap[mKey][g]).length === 0 && mKey !== 'ç·åˆè¨ˆ') return;
            
            const nameParts = mKey === 'ç·åˆè¨ˆ' 
                ? { prefecture: 'ç·åˆè¨ˆ', market: '' } 
                : mKey.includes('_') ? { prefecture: mKey.split('_')[0], market: mKey.split('_')[1] } : { prefecture: '', market: '' };
            
            let obj = { 
                key: mKey,
                prefecture: nameParts.prefecture,
                market: nameParts.market, 
                genderName: g,
            };
            let hasData = false;
            
            window.metricsMap.forEach(m => {
                const v = window.marketMap[mKey][g]?.[m.key] ?? null;
                obj[m.key] = v !== undefined && v !== null ? v : null;
                obj[`${m.key}Score`] = null; 
                if (v !== undefined && v !== null && v !== 0) {
                     hasData = true; 
                }
            });

            if (hasData || mKey === 'ç·åˆè¨ˆ') {
                window.parsedDataByGender[g].push(obj);
            }
        });
    });

    ['é›„', 'é›Œ', 'è¨ˆ'].forEach(g => {
        window.parsedDataByGender[g] = 
            window.parsedDataByGender[g].filter(row => 
                row.key === 'ç·åˆè¨ˆ' || 
                window.metricsMap.some(m => row[m.key] !== null && row[m.key] !== 0)
            );
    });

    if (window.parsedDataByGender['è¨ˆ'].length === 0 && window.parsedDataByGender['é›„'].length === 0 && window.parsedDataByGender['é›Œ'].length === 0) {
        if (errorDiv) errorDiv.textContent = "æœ‰åŠ¹ãªå¸‚å ´ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
        return;
    }

    if (typeof calculateScores === 'function') calculateScores(); 
    if (typeof renderTables === 'function') renderTables();
}

// --- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© ---
function handleDataInput() {
    window.sortState = {
        'é›„': { key: null, dir: 'desc' }, 
        'é›Œ': { key: null, dir: 'desc' },
        'è¨ˆ': { key: null, dir: 'desc' }
    };
    processData();
}

function processDataFromControls() {
    processData(); 
}

// --- åˆæœŸåŒ–ãƒ­ã‚¸ãƒƒã‚¯ ---
window.onload = function() {
    const dataInput = document.getElementById('dataInput');
    const targetMonthElement = document.getElementById('targetMonth');

    // ğŸ’¥ ä¿®æ­£ç®‡æ‰€ 6: ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«ç¾åœ¨ã®æœˆã‚’è¨­å®š ğŸ’¥
    if (targetMonthElement) {
        // ç¾åœ¨ã®æ—¥ä»˜ã‚’å–å¾—
        const today = new Date();
        // ç¾åœ¨ã®æœˆï¼ˆ0-11ï¼‰ã«1ã‚’è¶³ã—ã¦1-12ã®æ•°å€¤ã«ã™ã‚‹
        const currentMonth = today.getMonth() + 1; 
        
        // å…¥åŠ›æ¬„ãŒç©ºã®å ´åˆã«ã®ã¿è¨­å®š
        if (!targetMonthElement.value) {
            targetMonthElement.value = currentMonth;
        }
    }

    dataInput.addEventListener('input', handleDataInput);
    targetMonthElement.addEventListener('input', processDataFromControls);
};
</script>

</body>
</html>
